INTRODUCTION ------------------------------------------------------------------------------------------------------

class MainApp {
    public static void main(String[] args) {
        System.out.println("Bonjour tout le monde ! :)");
    }
}


---------------------------------------------------------------------------------------
Type        Type "Objet"    Place en        Fourchette de 
Primitif	Associ√©	        M√©moire	        Valeurs (Min & Max)
---------------------------------------------------------------------------------------
boolean	    Boolean	        1 octet	        true (1), false (0)
byte	    Byte	        1 octet	        -128 √† 127
char	    Character	    2 octets	    Unicode (65536 caract√®res disponibles)
short	    Short	        2 octets	    -32768 √† 32767
int	        Integer	        4 octets	    -2 147 483 648 √† 2 147 483 647
long	    Long	        8 octets	    -2<sup>63</sup> √† +2<sup>63</sup>-1
float	    Float	        4 octets	    1.4x10<sup>-45</sup> √† 3.4x10<sup>38</sup>
double	    Double	        8 octets	    4.9x10<sup>-324</sup> √† 1.7x10<sup>308</sup>
---------------------------------------------------------------------------------------

Notation d'un nombre :
    * 14 
    * 18056
    * 1_128_8531_876 (avec un s√©parateur de millier pour la lisibilit√©)


Base num√©rique : (on peut le fais dans n'importe quel type m√™me String)
    * d√©cimale (10 => 0 √† 9) : 0b110101110  (pr√©fix√© par 0b____ ou \b) 
    * binaire (2 => 0 et 1) : 110_101_110
    * octale (8 => 0 √† 7) : 0755            (pr√©fix√© par 0____ ou \)
    * hexad√©cimale (16 => 0 √† F) :0xAF45    (pr√©fix√© par 0x____ ou \x)


caract√®res sp√©ciaux : 
    \n : nouvelle ligne
    \t : tabulation
    \r : retour chariot
    \b : retour arri√®re
    \f : nouvelle page


FLUX DE CONTROLE ------------------------------------------------------------------------------------------------------

Les conditions on peut l'√©crire sans les accolades sur une seule ligne
    if (value == 24 || value == 16) 
        System.out.println("Oui !"); 
    else if(value == 14)
        System.out.println("value ne vaut 14");
    else
        System.out.println("value ne vaut ni 24 ni 16 ni 14");
        
Le "switch" peut etre √©cris comme ceci :
	public static String categorieDeFilm(final String film) {
	    var resultat = switch(film) {									// le resultat de switch vont directement dans "resultat"
	        case "Star Wars" -> "Science fiction";
	        case "Blanche neige", "La petite sir√®ne" -> "Disney";
	        case "Indiana Jones" -> {									// bloc en plusieurs lignes
	            String categorie = "Aventure";
	            yield categorie;										// yield => "categorie" est retourn√© par le switch mais pas par la fonction
	        }															// uniquement depuis Java 14
	        default -> "Inconnu";
	    };
	    return resultat;
	}
        
Le structures it√©ratives = boucle
	public static void main(String[] args) {
	    List<String> languageNames = Arrays.asList("Java", "PHP", "JavaScript");
	    for (String language : languageNames) {
	        System.out.println(language);
	    }
	}

CLASSE ------------------------------------------------------------------------------------------------------

NB : 
    * On ne peut pas cr√©er un projet java sans une Classe
    * 1 classe = 1 fichier
    * Les propri√©t√©s d'une classe est "private" par d√©faut si on ne me pas de port√©
    * les methodes d'une classes est "private" par d√©faut si on ne met pas de port√©
    * On peut d√©clarer des m√©thodes de m√™me nom si ils n'on pas les 
        m√™me signatures (arguments, type d'arguments, type de retour)
        √áa s'appelle le "Surcharge de m√©thode"				// polymorphisme √† la compilation

    * le "constructeur" porte le nom du classe et n‚Äôa pas de type retour   
        public class Person {
            public Person() {                           // Constructor
                System.out.println("Person created");
            }
        }

    * on met la methode "static" pour les classes qu'on ne veut pas instancier
        par exemple dans la m√©thode "main"

    * Les valeur par d√©fauts des arguments ne fonctionne pas en java
        public static String sayHello(String name, int NbSister = 1) {          // NO
            return "Hello " + name + " ! You have " + NbSister +" sisters";
        }
        (Sinon on peut simuler avec le surcharge de methodes en cr√©ant plusieurs 
        methode de m√™me nom)								// polymorphisme √† la compilation


Accesseurs : (encapsulation de donn√©es)
    # getters : r√©cup√©ration d'un propri√©t√© "private" d'une classe (lecture) et d'y ajouter une logique.
        public String getName() {
            return name != null ? name.toUpperCase() : "Nom non d√©fini";
        }

    # setters : modification d'un propri√©t√© "private" d'une classe (√©criture) et d'y ajouter une logique.
        public void setName(String name) {
            if (name != null && !name.isEmpty()) {
                this.name = name;
            } else {
                throw new IllegalArgumentException("Nom invalide");
            }
        }



Variable de Classe :
    private static int maxSoftware = 2;
    public Software(String licence) {
        if (maxSoftware > 0) {
            this.licence = licence;
            maxSoftware--;
        } else {
            System.out.println("Limite atteinte pour creer des logiciels");               
        }
    }


VARIABLE ------------------------------------------------------------------------------------------------------

D√©claration de variable : 
    int tab[] = new int[3];     // reserver en m√©moire 3 adresse de suite (length = 3)
    int[] tab1, tab2            // tous les variables sont des tableaux
    int tab1[], tab2            // seul tab1 est un tableau

    int[] tab = { 81, 25, 37 };             // OK
    int[] tab = new int[3]{81,25,37};       // OK

    System.out.println(tab);                // affiche l'adresse m√©moire du tab               
    System.out.println(tab[0]);             // affiche le valeur du 1er element du tab      

    * le Foreach ou le parcours d'un tableau 
        for (int element : tabX) {             
            System.out.println(element);
        }       

    * Le tableau √† deux dimensions
        int[][] tab = new int[2][3];        => tableau √† 2 lignes et 3 colonnes
        int[][] tab = {{ 81, 25, 37 }, { 81, 25, 37 }};  

    parcours tableau √† deux dimensions:
        for(int i = 0; i < tab.length; i++) {
            for(int j = 0; j < tab[i].length; j++) {
                System.out.println(tab[i][j]);
            }
        }

STRING ------------------------------------------------------------------------------------------------------

STRING : immuable (Contenue non-modifiable) => le syst√®me d√©truit l'ancien adresse et
            cr√©e un nouveau String sur un nouveau adresse (m√™me les methodes toUpperCase(), trim(),...)
    * instanciation de type de l'objet String
        String chaine1= "Hello"
        String chaine2= new String("world")

NB : les caract√®res misent dans un simple guillemet sont de type "char" non pas String

    * methode utiles : 
        - concat()
        - length() => la longueur du String
        - toUpperCase(), toLowerCase()            
        - trim() => enl√®ve les espaces au d√©but et √† la fin
        - replace("a","o")  => remplace les "a" en "o"
        - charAt(0) => r√©cup√®re le caract√®re au 1er position
        - substring(1, 3) => r√©cup√©rer 3 caract√®re √† partir du l'indice 1 (2√® caract√®re)
        - equals(chaine) => on ne peu pas comparer comme ceci (chaine1 == chaiine2) deux chaines 
        - replaceAll("/", " ") => remplacer tous les "/" en espace " "
        - maString.split ("-") => construire un tableau de String en le s√©parant la chaine "maString" quand il voit "-" 
        
        Exemples :
            String str3 = "See/you/soon";
            System.out.println(str3.replaceAll("/", " "));
            String[] tokens = str3.split("/");
            for (String token : tokens) {
                System.out.println(token);
            }

    * concatenation
        String ch = chaine1 + " " + chaine2                 // plus lourd en m√©moire
        String ch = chaine1.concat(" ").concat(chaine2)     // plus l√©ger, plus rapide

    * le StringBuilder / StringBuffer => immuable (Contenue modifiable) pas comme l'Objet string
        et ils ont le m√™me fonctionnement et meme utilisation
        StringBuilder maString = new StringBuilder();

        - length(), capacity()
        - append(<str>) => c'est comme la m√©thode "push" avec les array
        - insert(<index>, <string>) => ins√©rer une cha√Æne dans un position sp√©cifique


PACKAGE ------------------------------------------------------------------------------------------------------
        
Cr√©ation d'un package:
    - Cr√©er un fichier nompackage/NomFichier.java (nom de package : miniscule, nom de fichier : pascal case)
    - ins√©rer au debut de ligne le nom de package (comme le namespace) et on cr√©e un classe classique
    - s'il y a plusieurs dossier imbriquer, on le s√©pare par un point
        ex : com/weapons/Knife.java
            package com.weapons;
            public class Knife {
                public Knife() {
                    System.out.println("Knife instanci√© !");
                }
            }
    - Remarque : souvient toujours de mettre bien la port√©e de classe, des methodes et des propri√©t√©s (public,...)

Import du package :
    - Dans un autre Classe qui l'utilise, on l'import depuis son nom de package (nompackage.NomClass)
        Remarque : ici on import bien avec son nom de classe mais pas son nom de fichier.
    - si le package est dans le m√™me dossier (parfois), on n'a pas besoin de l'importer  
    - si on veut inclure tous les classes d'une package, on utilise le symbole √©toile "*" (import nompackage.*;)
        ex : src/main.java
            import com.weapons.Knife;          // import la classe
            public class Main {
                public static void main(String[] args) {
                    Knife weapon1 = new Knife();
                }
            }
            
 	NB : - il faut mettre "public" devant un classe ou un methode (surtout le constructeur) pour qu'un
 			autre fichier java dans un autre package peut l'utiliser (ex: Main.java)

    
LECTURE AU CLAVIER ------------------------------------------------------------------------------------------------------

    - BufferedReader : lecture de donn√©es en string (multithread)       // plus rapide
    - Scanner : lecture + parsing (int,float,...) (monothread)          // plus lent m√™me si monothread    

    * BufferedReader(<classReader>) : il a besoin de classe de lecture parc'il ne sait pas par d√©faut o√π est
            ce qu'il va lire (les p√©riph√©rique d'entr√©e, un flux, un filchier,...) 
        import java.io.BufferedReader;
        import java.io.InputStreamReader;                               // un flux d'entr√©e

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    
        System.out.print("Quel est votre nom ? ");
        String name = br.readLine();
    
        - readLine() => lire tous les chaines de caract√®re (sans √† la ligne "\n")  

        NB : il faut rendre la classe en "throws Exception" pour g√©rer les erreur en cas o√π 
            il ne peut pas lire les entr√©es SINON la classe ne se compile pas
            ex : public static void main(String[] args) throws Exception 

    * Scanner(<FluxLecture>) : il n'a besoin de classe de lecture mais juste un flux de lecture (System.in, System.out)
        import java.util.Scanner;

        Scanner sc = new Scanner(System.in);
        
        System.out.print("Quel est votre age ? ");
        int age = sc.nextInt();
        System.out.println("Vous avez " + age + " ans ");
        sc.close();
    
        - nextLine() => lire tous les chaines entr√©e (sans √† la ligne "\n")  
        - nextInt() => lire tous les chaines entr√©e + parseInt
        - nextChar() => lire tous les chaines entr√©e + parseChar
        - nextByte() => lire tous les chaines entr√©e + parseByte
        - nextInFloat() => lire tous les chaines entr√©e + parseFloat
        - nextBoolean() => lire tous les chaines entr√©e + parseBoolean

        NB : 
            * pas besoin "throws Exception"  


EXCEPTION ------------------------------------------------------------------------------------------------------

    Try {
        System.out.print("Quel est votre age ? ");                      // 1 seul block "try"
        int age = sc.nextInt();
        System.out.println("Vous avez " + age + " ans ");
    }
    catch (NomException1 e) {                                           // s'execute si NomException1 se produit
        System.out.println("age n'est pas un nombre");
    }
    catch (NomException2 e) {                                           // s'execute si NomException2 se produit
        System.out.println("age trop grand");
    }
    catch (Exception e) {                                               // s'execute si un exception en g√©n√©ral se produit
        System.out.println("il y a une exception!");
    }
    finaly {
        System.out.println("cet text s'affiche s'il y a une exception ou pas");
    }
    
    NB: - L‚Äôexception NullPointerException est couramment nomm√©e NPE par les d√©veloppeurs Java.
		- NPE se prosuit quand on ex√©cute une m√©thode sur une variable qui vaut null.
		- Ce type de message s‚Äôappelle en anglais ‚Äústack trace‚Äù, cela donne la trace entre l‚Äôendroit o√π l‚Äôerreur a eu lieu 
			et le point d‚Äôentr√©e du programme :	
				Exception in thread "main" java.lang.NullPointerException: Cannot invoke "java.util.Set.size()" because 
				the return value of "ej.Kit.getMotsCles()" is null
				at firstproject.Main.main(Main.java:8)
		- Le mot-cl√© "throw" sans "s" suivi de l‚Äôinstanciation d'une sorte d'Exception permet de lever l‚Äôexception.
				 throw new IllegalArgumentException();
		- Java nous contraint √† ajouter √† la signature de la m√©thode l‚Äôinformation : throws Exception		// avec s
				Bloc(final int hauteur) throws IllegalBlocException {
				    if(hauteur < MIN_HAUTEUR) {
				        throw new IllegalBlocException();
				    }
		- si c'est sur un constructeur, tous les constructeurs des classes filles doivent √©galement 
			ajouter throws IllegalBlocException √† leur signature.
		- De plus, le code de la classe Main sera oblig√© :
				* soit de mettre un try catch autour de l‚Äôappel du constructeur.
				* soit de mettre un throws IllegalBlocException √† la m√©thode main pour qu‚Äôelle redirige √† son tour cette exception.
		- RuntimeException et ses classes filles ont le droit √† un traitement particulier en ce sens que nous 
			n'avons pas besoin de sp√©cifier dans la signature de la m√©thode (comme RuntimeException et IllegalArgumentException)

HERITAGE ------------------------------------------------------------------------------------------------------

NB : 
    - toute les classes h√©rite de la classe "Object"
    - la port√© "protected" rend une propri√©t√© parent accessible uniquement par ces enfants et petit-enfants
    - "extends" rend une classe enfant d'une autre classe 
    - la methode super() veut dire utiliser le constructor de la classe parent
    - la super.move() veut dire utiliser le methode "move()" de la classe parent
    - les enfants peut utiliser les methodes de la classe sup√©rieur
    - en java, une classe ne peut pas h√©rit√© de plusieurs parents (h√©ritage multiple )
    - Une instance d‚Äôune classe fille peut √™tre affect√©e √† une variable typ√©e par la classe m√®re   
    	Horse unChaval = new Pegasus();   						// l'inverse n'est pas possible
    															// unChaval ne peut pas utiliser la methode sp√©cifique de Pegassus car c'est typ√© Horse
    - M√™me si la variable qui contient l‚Äôinstance d‚Äôune classe fille est typ√©e par la classe m√®re, 
    	lorsqu‚Äôune m√©thode est red√©finie, c‚Äôest le code de la classe fille qui est ex√©cut√©.			// polymorphisme √† l‚Äôex√©cution
    - on y ajoute l‚Äôannotation @Overidde juste avant la signature pour informer qu‚Äôune m√©thode est red√©finie.
    - mot cl√© "final" :
        * final nomClass = ce classe n'est pas extendable 
        * final nomMethode = ce methode n'est pas redefinissable dans les classe enfants  
        * final nomVariable = ce classe n'est pas modifiable (constant)
     

    ex : Horse.java
        package jc.entities;
        public class Horse {
            protected String name;
            protected int posX;
            protected int posY;
            public Horse(String name) {
                this.name = name;
                this.posX = 50;
                this.posY = 50;
            }
            public void move(int x, int y) {
                this.posX = x;
                this.posY = y;
                System.out.println("Le Cheval se d√©place (X = " + this.posX + ", Y = " + this.posY + ")");
            }
        }

    ex : Pegasus.java        
        package jc.entities;
        public class Pegasus extends Horse {
            protected int posZ;
            public Horse(String name) {
                super();
                this.posY = 50;
            }
            public void move(int x, int y) {
                this.posX = x;
                this.posY = y;
                System.out.println("La P√©gase s'envole dans les airs (X = " + this.posX + ", Y = " + this.posY + ", Z = " + this.posZ +")");
            }
        }


CLASSE ABSTRAITE -------------------------------------------------------------------------------------------

    -  Une classe abstraite est une classe qui ne peut pas √™tre instanci√©e directement. 
    -  Elle sert de mod√®le pour d'autres classes.
    
    Caract√©ristiques principales :
        * Peut contenir des m√©thodes abstraites (sans impl√©mentation => qu'on ne d√©finit pas dans la classe)        => au moins une
            et des m√©thodes concr√®tes (avec impl√©mentation => qu'on d√©finie dans la classe).
        * Peut avoir des variables d'instance (propri√©t√©), des constructeurs, et des m√©thodes avec un corps.
        * Une sous-classe doit h√©riter de la classe abstraite et impl√©menter toutes ses m√©thodes abstraites, 
            sauf si la sous-classe elle-m√™me est d√©clar√©e abstraite.
        * peut √©tendre d'une autre classe abstraite

METHODE ABSTRAITE -------------------------------------------------------------------------------------------

    - Une m√©thode abstraite est une m√©thode qui n‚Äôa pas de corps (pas de code dans les accolades). 
    - Elle est uniquement d√©finie pour √™tre impl√©ment√©e par des sous-classes.

Caract√©ristiques principales :
        * Elle est d√©clar√©e avec le mot-cl√© abstract.
        * Elle ne peut exister que dans une classe abstraite.
        * Elle force les classes d√©riv√©es √† fournir une impl√©mentation.


INTERFACE ---------------------------------------------------------------------------------------------------

    - Une interface en Java est un "contrat". Ce "contrat" stipule que toute classe qui impl√©mente une 
        interface doit fournir des impl√©mentations pour toutes les m√©thodes d√©clar√©es dans cette interface.
    - en terme d'explication, c'est comme si une interface c'est une classe abstraite dont toute les methodes
        sont toutes abstraites.

    - NB :
    	* elle peut avoir des variables qui sont automatiquement public, static et final, on dit que ce sont des constantes.
        * on n'a pas besoin de sp√©cifi√© "public" et "abstract" car toutes est publique et abstrait par d√©faut,
            mais on peut aussi le faire.
        * on fait "interface" au lieu de "class"
        * peut √©tendre d'une autre interface (extends)
        * on emploie le mot cl√© "implements" si une classe veut impl√©menter une interface (Rq : les extends d'abord)
        * une classe peut impl√©menter plusieurs interface (impl√©mentation multiple)
        * On ne peut pas forcer une classe abstraite de redefinir une methode de l'interface m√™me s'il
        	l'implemente, par contre les classes fille doit red√©finir la methode. 
        * Une variable peut √™tre typ√©e par une interface.
    
    ex : Volant.java
    interface Volant {
        void voler();
    }

    ex : Oiseau.java
    public class Oiseau implements Volant {
        @Override
        public void voler() {
            System.out.println("L'oiseau vole.");
        }
    }

    ex : Avion.java
    public class Avion implements Volant {
        @Override
        public void voler() {
            System.out.println("L'avion vole.");
        }
    }
    
    NB: - Les interfaces fonctionnelles ont la particularit√© de d√©finir une seule m√©thode abstraite  
			@FunctionnalInterface
			public interface IAffichage {
			    void afficher(String texte);
			}


EXPRESSION LAMBDA ---------------------------------------------------------------------------------------------

	Une expression lambda est une fonction anonyme car elle n‚Äôa pas besoin d‚Äô√™tre d√©finie dans le cadre 
	d‚Äôune classe. Gr√¢ce √† cela, cette fonction est consid√©r√©e comme une valeur qu‚Äôon peut affecter √† une 
	variable ou pass√© en param√®tre d‚Äôune autre fonction.
	Syntaxe:
		(param√®tres) -> { corps de la fonction }
		‚úîÔ∏è Les param√®tres sont pass√©s entre ().
		‚úîÔ∏è La fl√®che -> s√©pare les param√®tres et le corps de la fonction.
		‚úîÔ∏è Si le corps contient une seule instruction, {} sont optionnels.
		
	NB : 
		- un interface fonctionnelle est le type associ√© √† une expression lambda
		
		- Il existe de nombreuses interfaces fonctionnelles (ou fonction anonyme) dans le langage Java, par exemple :
			Predicate : la m√©thode prend un param√®tre g√©n√©rique de type T et renvoie un bool√©en.
			Function : la m√©thode prend un param√®tre g√©n√©rique de type T et renvoie une valeur g√©n√©rique de type R.
			Consumer : la m√©thode prend un param√®tre g√©n√©rique de type T et ne renvoie rien.
			Runnable : la m√©thode ne prend pas de param√®tre et ne renvoie rien.
			
			// Callable : la m√©thode ne prend pas de param√®tre et renvoie une valeur g√©n√©rique de type R
		
		ex : 
			Consumer<String> fn = (mot) -> System.out.print(mot);	// on peut affecter √† une variable (ici c'est pas utile mais pour l'exemple)
			motCles.foreach(fn);									// foreach d'un objet Collection prend en param√®tre un fonction "Consummer"

            --------------------------------------------------------------------------------------------------------------------------------
            Interface	    R√¥le	                                            M√©thode principale              Exemple d‚Äôutilisation
            --------------------------------------------------------------------------------------------------------------------------------
            Predicate<T>	Teste une condition et retourne true/false	        boolean test(T t)	            Filtrage d‚Äôune liste                    // fn.test("Jean")      => return true
            Function<T, R>	Transforme un objet T en R	                        R apply(T t)	                Convertir un mot en longueur            // fn.apply("Jean")     => return "Jeannette"
            Consumer<T>	    Effectue une action sur T sans retour	            void accept(T t)	            Afficher un message                     // fn.accept("Jean")    => return void
            Runnable	    Ex√©cute une t√¢che sans param√®tre ni retour	        void run()	                    Thread                                  // fn.run()             => return void
            --------------------------------------------------------------------------------------------------------------------------------

        exemples : Predicate<T>
            Predicate<Integer> estPair = n -> n % 2 == 0;
            System.out.println(estPair.test(4)); // true
            System.out.println(estPair.test(7)); // false
            List<Integer> nombres = Arrays.asList(1, 2, 3, 4, 5, 6);
            List<Integer> pairs = nombres.stream().filter(estPair).collect(Collectors.toList());
            System.out.println(pairs); // [2, 4, 6]

        exemples : Function<T,R>
            Function<String, Integer> longueurMot = mot -> mot.length();
            System.out.println(longueurMot.apply("Java"));   // 4
            System.out.println(longueurMot.apply("Lambda")); // 6

        exemples : Consumer<T>
            Consumer<String> afficher = nom -> System.out.println("Bonjour " + nom);
            afficher.accept("Alice"); // Bonjour Alice
            List<String> noms = Arrays.asList("Bob", "Charlie", "David");
            noms.forEach(afficher);

        exemples : Runnable
            Runnable tache = () -> System.out.println("T√¢che ex√©cut√©e !");
            Thread thread = new Thread(tache);
            thread.start();

LES R√âF√âRENCES √Ä DES M√âTHODES (Method reference) --------------------------------------------------------------

    permettent de remplacer une expression lambda lorsqu'elle appelle directement une m√©thode existante. 
    Elles rendent le code plus lisible et concis.

    Une r√©f√©rence √† une m√©thode utilise :: (double deux-points) et suit l'une des formes suivantes :
        ClassName::staticMethod      // R√©f√©rence √† une m√©thode statique
        objet::instanceMethod        // R√©f√©rence √† une m√©thode d'instance sur un objet existant
        ClassName::instanceMethod    // R√©f√©rence √† une m√©thode d'instance sur un objet arbitraire
        ClassName::new               // R√©f√©rence √† un constructeur

    Exemples : Remplace une lambda qui appelle une m√©thode statique
        Function<String, Integer> lambda1 = s -> Integer.parseInt(s);       // Lambda classique
        Function<String, Integer> refMethode = Integer::parseInt;           // Avec une r√©f√©rence de m√©thode

        System.out.println(refMethode.apply("123"));                        // 123

    Exemples : Utilis√© lorsque la m√©thode appartient √† une instance sp√©cifique
        String message = "Bonjour";
        Supplier<Integer> lambda2 = () -> message.length();                 // Lambda classique
        Supplier<Integer> refMethode = message::length;                     // Avec une r√©f√©rence de m√©thode

        System.out.println(refMethode.get());                               // 7

    Exemples : Utilis√© lorsqu‚Äôon travaille sur une collection d'objets
        List<String> noms = Arrays.asList("Alice", "Bob", "Charlie");
        noms.forEach(nom -> System.out.println(nom));                       // Lambda classique
        noms.forEach(System.out::println);                                  // Avec une r√©f√©rence de m√©thode

    Exemples : Utilis√© pour cr√©er un objet avec new
        Supplier<Voiture> lambda4 = () -> new Voiture();                    // Lambda classique
        Supplier<Voiture> refConstructeur = Voiture::new;                   // Avec une r√©f√©rence de constructeur

        refConstructeur.get();                                              // "Nouvelle voiture cr√©√©e !"


POLYMORPHISME ---------------------------------------------------------------------------------------------



COLLECTION ---------------------------------------------------------------------------------------------

La collection est une interface qui est l'ensemble de tous ce qui est structure de donn√©es (pile, liste, file,...). 
Elles peut stocker une quantit√© variable des ELEMENTS (donn√©es) qui est g√©rer de fa√ßon dynamique au niveau de la m√©moire.

Les classes qui implements l'interface collection auront ces methodes :
    * add(ELEMENT) : ajouter un √©l√©ment
    * addAll(COLLECTION) : ajouter tous les elements d'une autre collection
    * clear() : supprimer tous les elements d'une collection 
    * remove(INDEX) : supprimer un element
    * contains(ELEMENT) : v√©rifier si elle contient un element
    * isEmpty() : v√©rifier si elle est vide
    * size() : v√©rifier le nombre d'element (length)
    * toArray() : transformer en Array classique
    * ... (voir la documentation)
    - Collections.sort(collections) => trie les elements de la collection (import java.util.Collections)
    - Collections.swap(collections, index, index) => √©changer les positions de deux √©l√©ments dans une collection


Les classes qui implements l'interface collection :
    * ArrayList, LinkedList, Vector, HashSet, TreeSet, Stack, HashMap, TreeMap


D√©finition du fichier "ressources/tableau-specificite-des-classes-de-collections.png":
    ~ ordonn√©es : indique si les √©l√©ments de la collection conservent l'ordre dans lequel ils ont √©t√© ajout√©s
    ~ doublons : pr√©cise si la collection autorise plusieurs occurrences du m√™me √©l√©ment (doublons)
    ~ acc√®s direct : indique si les √©l√©ments de la collection peuvent √™tre acc√©d√©s rapidement par un index ou une cl√©. 
                    Si Non, n√©cessite une it√©ration pour trouver un √©l√©ment.
    ~ valeurs nulles : indique si la collection peut contenir des valeurs nulles (√©l√©ments ou cl√©s nulles)
    ~ thread safe : Pr√©cise si la collection est s√ªre pour une utilisation concurrente (acc√®s simultan√© par plusieurs 
                    threads sans provoquer d'erreurs ou de comportements inattendus).
                    ‚úÖ : La collection est con√ßue pour √™tre utilis√©e dans des environnements multithreads.
                    ‚ùå : La collection n'est pas thread-safe et n√©cessite une synchronisation explicite si 
                            utilis√©e avec plusieurs threads.
 
LISTE ---------------------------------------------------------------------------------------------


    Les classes qui implements l'interface LIST sont : (LIST √©tend de COLLECTION)

        * ArrayList : (MonoT, acc√®s direct, optimis√© pour la lecture)               // Tableau dynamique
        * LinkedList :  (MonoT, optimis√© pour l'√©criture)                           // liste cha√Æn√© (doublement cha√Æn√©)
        * Vector : (MultiT, acc√®s direct, optimis√© pour la lecture)                 // Obsolete pour java 21
        * Stack (√©tend Vector) : MultiT, LIFO(pile), extends Vector

    Ces 04 classes ont les sp√©cificit√©s de : 
        - permettent de travailler avec des elements ordonn√©es,
        - acceptent les doublons,
        - acceptent les valeurs nulles


    utilisation : 
        * ArrayList<nomClass> nomVariable = new ArrayList<nomClass>(10);        // nomClass => String, Integer, NomClasse,... (pas de type primitive)
                                                                                // 10 => capacity (on peut ne pas sp√©cifi√© paske c'est dynamique)
                                                                                
        * Vector<nomClass> nomVariable = new Vector<nomClass>(10);              // pour la solution multithread

            --------------------------------------------------------------------------------------------------
                Aspect	            Array	                        ArrayList
            --------------------------------------------------------------------------------------------------
                Taille	            Fixe	                        Dynamique
                Type de donn√©es	    Primitifs et Objets	            Uniquement Objets
                M√©thodes	        Pas de m√©thodes int√©gr√©es	    M√©thodes pour ajouter, supprimer, etc.
                Performance	        Plus rapide pour des 	        Plus lent en raison de sa flexibilit√©
                                    op√©rations simples
                Framework 	        Pas directement compatible	    Compatible
                Collections
            --------------------------------------------------------------------------------------------------
            

            - nomVariable.add(cat) => ajouter l'instance cat de Cat dans nomVariable de type ArrayList<Cat>
            - nomVariable.add(25) => ajouter le nombre "25" dans nomVariable de type ArrayList<Integer>
            - nomVariable.get(2) => r√©cup√©rer le 3√® element de collection nomVariable (acc√®s direct)


        * LinkedList<nomClass> nomVariable2 = new LinkedList<nomClass>();               // liste cha√Æn√©e
            
            - nomVariable2.add(cat) => ajouter l'instance cat de Cat dans nomVariable2 de type LinkedList<Cat> √† la fin
            - nomVariable2.addFirst(cat) => ajouter l'instance cat de Cat dans nomVariable2 de type LinkedList<Cat> au debut
            - nomVariable2.remove(cat) => enlever l'instance cat de Cat dans nomVariable2 de type LinkedList<Cat> √† la fin
            - nomVariable2.removeFirst(cat) => enlever l'instance cat de Cat dans nomVariable2 de type LinkedList<Cat> au debut
            - nomVariable2.getFirst()
            ~ ListIterator : on doit it√©rer la linkedList parce que ses elements n'est pas accessible directement 
                ListIterator<nomClass> iter = nomCollection.listIterator();             // import java.util.ListIterator
                while (iter.hasNext()) {
                    iter.next().nomMethodeClasse();                                      // iter.next = element
                }


            Avantages
                Insertion et suppression rapides (surtout au d√©but ou au milieu).
                Ordre conserv√©.
                Peut √™tre utilis√©e comme une pile (Stack), une file ou une file double (Deque).
            Inconv√©nients
                Acc√®s lent par index : Chaque acc√®s n√©cessite de parcourir la liste depuis le d√©but ou la fin.
                Consommation m√©moire √©lev√©e : Chaque n≈ìud utilise plus de m√©moire (en raison des r√©f√©rences au pr√©c√©dent et au suivant).
                Non thread-safe : N√©cessite une synchronisation manuelle si utilis√©e par plusieurs threads.

                --------------------------------------------------------------------------------------------------
                    Aspect	            LinkedList	                    ArrayList
                --------------------------------------------------------------------------------------------------
                    Taille dynamique	Oui	                            Oui
                    Acc√®s par index	    Lent (parcours des n≈ìuds)	    Rapide (tableau sous-jacent)
                    Ajout/Suppression	Rapide pour d√©but/milieu	    Rapide pour la fin
                    Structure interne	Doublement cha√Æn√©e	            Bas√©e sur un tableau
                    M√©moire	            Plus gourmand 	                Moins gourmand
                                        (stocke des r√©f√©rences)
                --------------------------------------------------------------------------------------------------


        * Stack<nomClass> nomVariable3 = new Stack<nomClass>();               // pile (LIFO), import java.util.ListIterator
        
            - nomVariable3.push(cat) => ajouter l'instance cat de Cat dans la collection nomVariable3
            - nomVariable3.pop() => supprimer le dernier instance dans la collection nomVariable3 
            - nomVariable3.peek() => r√©cup√©rer le dernier instance dans la collection nomVariable3

            
FILE (Queue) - FIFO (First in, First out) -----------------------------------------------------------

    L‚Äôinterface "Queue" repr√©sente une file d'attente (FIFO : First In, First Out).c'est une enfant de 
    Collection dans ressources/interface-enfant-de-collection.png: (file d'attente)
    
    Les deux principales sous-interfaces :

        - PriorityQueue
            Une PriorityQueue est une file o√π les √©l√©ments ne sont pas n√©cessairement trait√©s selon leur ordre d'insertion, 
            mais selon leur priorit√© d√©finie par un ordre naturel (Comparable) ou un comparateur (Comparator).

            * Caract√©ristiques :
                ~ ‚úÖ Ordonn√©e : Ordre bas√© sur la priorit√© des √©l√©ments.
                ~ ‚úÖ Doublons
                ~ ‚ùå acc√®s direct.
                ~ ‚ùå non thread-safe.
                ~ ‚ùå valeurs null.

            * PriorityQueue<nomClass> queue = new PriorityQueue<>();        // nomClass n'a pas besoin d'implementer l'interface comparable 
                                                                                parce qu'il est ordonn√©e par l'ordre d'insertion
            * queue.offer(element) => ajout d'√©l√©ment
            * queue.poll(element) => r√©cup√©rer ensuite supprimer le 1er √©l√©ment selon l'ordre de priorit√©

        
        - Deque (Double-Ended Queue = Tableau doublement cha√Æn√©e)
            L‚Äôinterface "Deque" est une file d'attente qui permet d'ajouter et de retirer des √©l√©ments √† 
            la fois au d√©but et √† la fin. Elle est plus flexible que Queue et peut √™tre utilis√©e comme une 
            pile (LIFO) ou une file classique (FIFO).

            * Caract√©ristiques :
                ~ ‚úÖ Ordonn√©e : Ordre d'insertion.
                ~ ‚úÖ Doublons
                ~ ‚ùå acc√®s direct.
                ~ ‚ùå non thread-safe.
                ~ ‚ùå valeurs null.
                ‚úÖ Permet l'ajout/suppression des deux c√¥t√©s.
                ‚úÖ Impl√©ment√©e par LinkedList ou ArrayDeque(plus rapide).
                ‚úÖ ArrayDeque est plus rapide que Stack et ne permet pas null.

            * ArrayDeque :
                ArrayDeque<nomClass> adeque = new ArrayDeque<>();            // nomClass doit implementer l'interface comparable 
                                                                            // les Integer, String,... impl√©mentent d√©j√† comparable
                ~ adeque.addFirst(element) / addLast(element)
                ~ adeque.removeFirst() / removeLast()
                ~ adeque.getFirst() / getLast()
                ~ adeque.offertFirst(element) / offertLast(element)
                ~ adeque.pollFirst() / pollLast()
                ~ adeque.peekFirst() / peekLast()
                ~ adeque.removeFirstOccurrence(4) : supprimer le 1er valeur "4" du collection "adeque"
                ~ adeque.removeLastOccurrence(5) : supprimer le dernier valeur "4" du collection "adeque"



ENSEMBLE (SET) ------------------------------------------------------------------

    L'interface Set<E> (du package java.util) est une collection qui ne permet pas les doublons. 
    Elle est principalement utilis√©e lorsque vous devez stocker des √©l√©ments uniques et que l'ordre 
    des √©l√©ments n'est pas votre priorit√©.
    
    * Caract√©ristiques :
        ‚ùå Doublons.
        ‚ùå non thread-safe.

    1. HashSet ‚Äì Unicit√© sans ordre
        Un HashSet est bas√© sur une table de hachage, garantissant que chaque √©l√©ment est unique 
        gr√¢ce √† la m√©thode hashCode().

        Caract√©ristiques :
            ‚ùå ordonn√©es.
            ‚ùå Non thread-safe
            ‚úÖ acc√®s direct.
            ‚úÖ Autorise un √©l√©ment null, mais pas plusieurs.
            ‚úÖ Tr√®s performant pour les recherches, ajouts et suppressions (O(1) en moyenne).

        Syntaxe : 
            HashSet<String> set = new HashSet<>();

    
    2. LinkedHashSet ‚Äì Unicit√© avec ordre d‚Äôinsertion
        C‚Äôest une variante de HashSet qui pr√©serve l‚Äôordre d‚Äôinsertion des √©l√©ments.

        Caract√©ristiques :
            ‚úÖ ordonn√©e : l‚Äôordre d‚Äôinsertion.
            ‚úÖ Un peu plus lent que HashSet, car il utilise une liste doublement cha√Æn√©e pour suivre l‚Äôordre.
            ‚úÖ Permet un null unique.
            
        Syntaxe : 
            HashSet<String> set = new HashSet<>();


    3. TreeSet ‚Äì Unicit√© avec tri automatique (arbre binaire)
        Un TreeSet est bas√© sur un arbre binaire √©quilibr√© (Red-Black Tree), ce qui permet 
        de stocker les √©l√©ments tri√©s.

        Caract√©ristiques :
            ‚úÖ ordonn√©e : l‚Äôordre naturel (Comparable) ou un Comparator personnalis√©.
            ‚ùå Non thread-safe
            ‚ùå acc√®s direct.
            ‚ùå valeurs null.
            ‚ùå Plus lent que HashSet pour l‚Äôinsertion et la recherche (O(log N) au lieu de O(1)).
            
        Syntaxe : 
            TreeSet<Integer> TSet = new TreeSet<>();

            ~ TSet.first(element) / last(element) : r√©cup√©rer
            ~ TSet.headSet(element) : r√©cup√©rer un sous ensemble de la collection depuis le debut jusqu'√† "element" (element exclus)
            ~ TSet.tailSet(element) : r√©cup√©rer un sous ensemble de la collection depuis "element" jusqu'√† la fin (element inclus)
            ~ TSet.subSet(elem1, elem2) : r√©cup√©rer un sous ensemble de la collection depuis "elem1" jusqu'√† la "elem2" (elem1 inclus, elem2 exclus)



    NB : - tous les Classes d'elements qui vont s'ajouter dans la collection "SET" vont devoir r√©-implementer
            les methodes "hashCode()" et "equals()" pour que les interface "SET" recherche les doublons. (sauf Integer, String,...)
         - les elements de "TreeSet" devoir r√©-implementer les comparators.




CARTE (MAP) (key : value) ------------------------------------------------------------------

    L'interface Map<K, V> (du package java.util) repr√©sente une collection cl√©-valeur, o√π :
        - Chaque cl√© est unique (pas de doublons de cl√©).
        - Chaque valeur est associ√©e √† une cl√©.
        - L'acc√®s aux valeurs se fait via les cl√©s.
    
    * Caract√©ristiques :
        ‚úÖ acc√®s direct.
        ‚ùå Doublons (key).
        ‚ùå non thread-safe.

    1. HashMap ‚Äì Rapide mais sans ordre
        Une HashMap est bas√©e sur une table de hachage et permet un acc√®s tr√®s rapide aux valeurs via 
        leurs cl√©s.

        Caract√©ristiques :
            ‚ùå ordonn√©e
            ‚úÖ une seule cl√© null et plusieurs valeurs null.
            ‚úÖ Excellente performance pour la recherche, l‚Äôajout et la suppression (O(1) en moyenne).

        Syntaxe : 
            HashMap<String, String> HMap = new HashMap<>();

            ~ HMap.put(key, value) : ajouter un element
            ~ HMap.get(key) : r√©cup√©rer un la valeur de l'element qui a la cl√© "key"
            ~ HMap.containsKey(key) / contains(value)
            ~ for( String k : HMap.keySet()) : parcours HMap
                * keySet() => ensemble des cl√©s
                * values() => ensemble des valeurs
            ~ for( Map.Entry<String, String> entry : HMap.entrySet()) => ensemble des cl√©s-valeurs (des entr√©es, des enregistrements)
                * entry.getKey()
                * entry.getValue()


    2. LinkedHashMap ‚Äì Ordre d‚Äôinsertion pr√©serv√©
        Un LinkedHashMap est une version am√©lior√©e de HashMap qui conserve l‚Äôordre d‚Äôinsertion des √©l√©ments.

        Caract√©ristiques :
            ‚úÖ Conserve l‚Äôordre d‚Äôinsertion.
            ‚úÖ Permet une seule cl√© null et plusieurs valeurs null.
            ‚ùå L√©g√®rement plus lent que HashMap, car il maintient une liste cha√Æn√©e pour l‚Äôordre.

        Syntaxe : 
            LinkedHashMap<Integer, String> LHmap = new LinkedHashMap<>();


    3. TreeMap ‚Äì Tri automatique des cl√©s
        Un TreeMap est bas√© sur un arbre binaire √©quilibr√© (Red-Black Tree) et trie automatiquement les cl√©s.

        Caract√©ristiques :
            ‚úÖ Ordonn√©e : ordre naturel (Comparable) ou un Comparator.
            ‚úÖ Ne permet pas de cl√© null, mais permet des valeurs null.
            ‚ùå Plus lent que HashMap pour l‚Äôajout et la suppression (O(log N) au lieu de O(1)).

        Syntaxe : 
            TreeMap<Integer, String> Tmap = new TreeMap<>();

            ~ Tmap.put(element) / last(element) : ajout / r√©cup√©rer
            ~ TreeMap<Integer, String> map = new TreeMap<>((a, b) -> b - a);        // Trier (alphabet d√©croissant)

    -----------------------------------------------------------------------------------------------------------------
    Crit√®re	            HashMap	              LinkedHashMap	            TreeMap	            Hashtable
    -----------------------------------------------------------------------------------------------------------------
    Ordre des           ‚ùå Non garanti	    ‚úÖ Ordre d‚Äôinsertion	    üî¢ Tri√© par cl√©	    ‚ùå Non garanti
    √©l√©ments	
    Performance	        üöÄ O(1)	             üê¢ O(1) (plus lent)	  üêå O(log N)	      üê¢ O(1) (moins efficace)
    (Ajout/Suppression)
    Recherche	        O(1)	              O(1)	                    O(log N)	        O(1)
    Cl√© null autoris√©e	‚úÖ Oui (une seule)	‚úÖ Oui (une seule)	    ‚ùå Non	            ‚ùå Non
    Valeur null 	    ‚úÖ Oui	            ‚úÖ Oui	                ‚úÖ Oui	            ‚ùå Non
    autoris√©e
    Thread-safe ?	    ‚ùå Non	            ‚ùå Non	                ‚ùå Non	            ‚úÖ Oui
    -----------------------------------------------------------------------------------------------------------------
    
    Quand utiliser quel Map ?
        ‚úî Utilisez HashMap si vous voulez les meilleures performances sans vous soucier de l‚Äôordre.
        ‚úî Utilisez LinkedHashMap si vous voulez conserver l‚Äôordre d‚Äôinsertion.
        ‚úî Utilisez TreeMap si vous avez besoin d‚Äôun tri automatique des cl√©s.
        ‚úî √âvitez Hashtable, utilisez plut√¥t ConcurrentHashMap si vous avez besoin d‚Äôune Map



ENUMERATION (ENUM) -------------------------------------------------------------------------

    En Java, une √©num√©ration (ou "enum") est un type de classe sp√©cial qui permet de d√©finir un 
    ensemble fixe de constantes nomm√©es.
        public enum Jour {
            LUNDI, MARDI, MERCREDI, JEUDI, VENDREDI, SAMEDI, DIMANCHE
        }

        Jour jour = Jour.LUNDI;
        System.out.println(jour);       // LUNDI


    * Associer des valeurs avec les "enum"
        public enum Statut {
            ACTIF(1), INACTIF(0), SUSPENDU(-1);

            private int code; // Attribut

            Statut(int code) { // Constructeur, on met le parametre meme si on l'appelle pas
                this.code = code;
            }

            public int getCode() { // Getter
                return code;
            }
        }

        Statut s = Statut.ACTIF;
        System.out.println(s.getCode()); // 1


    * Ajouter des m√©thodes (ex : Trouver un enum √† partir d‚Äôun code)

        public enum Statut {
            ACTIF(1), INACTIF(0), SUSPENDU(-1);

            private int code;

            Statut(int code) {		// on met le parametre meme si on l'appelle pas
                this.code = code;
            }

            public int getCode() {
                return code;
            }

            public static Statut fromCode(int code) {
                for (Statut s : Statut.values()) {
                    if (s.getCode() == code) {
                        return s;
                    }
                }
                throw new IllegalArgumentException("Code inconnu : " + code);
            }
        }

        Statut s = Statut.fromCode(1);
        System.out.println(s); // ACTIF


    * Diff√©rence entre enum et final static
        Avant les enum, on utilisait souvent final static pour repr√©senter des constantes :

            public class Statut {
                public static final int ACTIF = 1;
                public static final int INACTIF = 0;
                public static final int SUSPENDU = -1;
            }

        üìå Pourquoi enum est mieux ?
            ‚úî S√©curit√© ‚Üí Impossible de mettre une valeur inconnue (ex: Statut.ACTIF est s√ªr).
            ‚úî Lisibilit√© ‚Üí Pas besoin de se souvenir des valeurs (1, 0, -1 sont abstraits).
            ‚úî Fonctionnalit√©s ‚Üí Peut contenir des m√©thodes et √™tre utilis√© avec switch.
            ‚úî comparaison ‚Üí avec simplemnt "=="

    
    ~ Statut.valueOf(element) : recuperer la valeur d'√©l√©ments de l'enum "Statut"
    ~ element.name() : recuperer le nom d'√©l√©ments d'une enum
    ~ element.ordinal() : recuperer le rang de l'enum (comme index)
    ~ for (Statut s : Statut.values()) : parcours (values => obtenir tous les √©l√©ments d'une enum)
    

NB : 
    - on ne peut pas √©tendre d'une Classe ni √©tendre une Enum (parce que c'est une classe final par d√©faut)
    - tout les attributs sont priv√© par d√©faut si on ne met pas de port√© (la liste des valeurs d'une enum ne sont pas des attribus)
    - on ne peut pas cr√©er un instance d'un Enum (parce que le constructeur est priv√©)
    - pour cr√©er une enum associ√© des valeurs, on doit lui fournir un constructeur.
    - comme pour tous les classes, les methodes et les attributs est "private" par d√©faut si on ne met pas "public" 
      dans sa signature. (mais la propri√©t√© reste priv√© m√™me si on lui met "public")
    - on peut mettre un enum dans une classe
	    public class GameController {
			enum GameState {
				AddPlayer, CardDealt, WinnerRevealed
			}




GENERICITE <T> --------------------------------------------------------------------------

    La g√©n√©ricit√© en Java est une fonctionnalit√© qui permet de cr√©er des classes, des interfaces et des 
    m√©thodes qui peuvent √™tre utilis√©es avec diff√©rents types de donn√©es sans avoir √† les sp√©cifier 
    explicitement √† chaque fois :

            public class Boite<T> {
                private T contenu;

                public Boite(T contenu) {
                    this.contenu = contenu;
                }

                public T getContenu() {
                    return contenu;
                }

                public void setContenu(T contenu) {
                    this.contenu = contenu;
                }
            }

            Boite<Integer> boiteEntier = new Boite<>(10);
            Boite<String> boiteChaine = new Boite<>("Bonjour");


        ~ public class Boite<T extends Number> : accepte tous les Objet qui √©tend la classe "Number"    (Box<Double> doubleBox = new Box<>(5.5))
        ~ class KeyValue<K, V> implements Pair<K, V> : implement l'interface Pair<K, V>                 ( Pair<Integer, String> p = new KeyValue<>(1, "One"); )
        ~ public static void printNumbers(List<? extends Number> numbers)
                List<Integer> intList = List.of(1, 2, 3);
                printNumbers(intList); // ‚úÖ OK, Integer est un Number
        ~ public static void addInteger(List<? super Integer> list)
                List<Number> numList = new ArrayList<>();
                addInteger(numList); // ‚úÖ OK, Number est une superclasse de Integer

    NB :
        En Java, on ne peut pas cr√©er directement un tableau de type g√©n√©rique.
        Solution : Utiliser Array.newInstance()
            class Box<T> {
                private T[] array;

                @SuppressWarnings("unchecked")
                public Box(Class<T> clazz, int size) {
                    array = (T[]) java.lang.reflect.Array.newInstance(clazz, size);
                }
            }
        
        Box<String> stringBox = new Box<>(String.class, 10);

    -----------------------------------------------------------------------------------------------------
        Crit√®re	            List<?> (Wildcard g√©n√©rique)	    List<T> (Type param√©tr√©)
    -----------------------------------------------------------------------------------------------------
        Flexibilit√©	        Accepte toutes les listes 	        Type unique d√©fini (List<T>, 
                            (List<Integer>, List<String>...)    ex: List<Integer>)
        Lecture (get())	    ‚úÖ Possible	                      ‚úÖ Possible
        Ajout (add())	    üö´ Impossible (sauf null)	       ‚úÖ Possible (ajout d'√©l√©ments du type T)
        Utilisation de T	‚ùå Pas de T, seulement Object	  ‚úÖ Utilisation directe de T
    -----------------------------------------------------------------------------------------------------
     Quand utiliser quoi ?
        ------------------------------------------------------------------------------------
            Cas d'usage	                                     Quelle version choisir ?
        ------------------------------------------------------------------------------------
            Lecture seule, sans modifier la liste	        List<?> (car plus flexible)
            Lecture + Ajout d‚Äô√©l√©ments du m√™me type	        List<T> (car permet les ajouts)
            M√©thode acceptant plusieurs types (Integer,	    List<?>
            String, etc.)
        ------------------------------------------------------------------------------------
    üìå Exemple pratique :
        List<?> : Id√©al pour une m√©thode d'affichage qui ne doit pas modifier la liste.
        List<T> : Id√©al pour une m√©thode qui manipule les √©l√©ments (ajout, suppression, transformation...).



    - Avantages de la g√©n√©ricit√© :
        S√©curit√© du type: La g√©n√©ricit√© permet de s'assurer que les donn√©es manipul√©es sont du bon type au 
                            moment de la compilation, ce qui √©vite les erreurs de type √† l'ex√©cution.
        R√©utilisabilit√© du code: La g√©n√©ricit√© permet de cr√©er des classes et des m√©thodes qui peuvent √™tre 
                            utilis√©es avec diff√©rents types de donn√©es, ce qui r√©duit la quantit√© de code √† √©crire et √† maintenir.
        Lisibilit√© du code: La g√©n√©ricit√© rend le code plus lisible en indiquant clairement le type de donn√©es
                            manipul√©es.



DATE ET DUR√âES --------------------------------------------------------------------------------

    1Ô∏è‚É£ LocalDate ‚Äì Manipulation de la date uniquement
        Utilis√© quand seule la date est importante (sans heure).

        Ex :
            import java.time.LocalDate;
            public class Main {
                public static void main(String[] args) {
                    // Date actuelle
                    LocalDate today = LocalDate.now();
                    System.out.println("Aujourd'hui : " + today);               // 2025-02-05 (Ann√©e - Mois - Jour)

                    // Date sp√©cifique (ann√©e, mois, jour)
                    LocalDate date = LocalDate.of(2025, 2, 5);      
                    System.out.println("Date sp√©cifique : " + date);            // 2025-02-05

                    // Ajouter/Soustraire des jours/mois/ann√©es
                    LocalDate futureDate = today.plusDays(10);
                    LocalDate pastDate = today.minusMonths(2);
                    System.out.println("Dans 10 jours : " + futureDate);        // 2025-02-15
                    System.out.println("Il y a 2 mois : " + pastDate);          // 2024-12-05

                    // Comparaison de dates
                    boolean isBefore = date.isBefore(today);
                    boolean isAfter = date.isAfter(today);
                    System.out.println("Est avant aujourd'hui ? " + isBefore);  // false
                    System.out.println("Est apr√®s aujourd'hui ? " + isAfter);   // false
                }
            }

            instanciation :
                ~ LocalDate.EPOCH() : cr√©er une date "1970-01-01"
                ~ LocalDate.now() : cr√©er une date d'aujourd'hui
                ~ LocalDate.of(1988, 03, 14) : cr√©er une date sp√©cifique (ann√©e - mois - jour)
            methodes :
                ~ myDate.getYear() : r√©cup√©rer l'ann√©e
                ~ myDate.getMonthValue() : r√©cup√©rer le mois num√©rique (ex: 03)
                ~ myDate.getMonth() : r√©cup√©rer le mois literal (ex: MARCH)
                ~ myDate.getDayOfMonth() : r√©cup√©rer le mois num√©rique (ex: 22)
                ~ myDate.getDayOfWeek() : r√©cup√©rer le mois literal (ex: Saturday)
                ~ myDate.plusYears(4) / plusMonths(15) / plusDays(35) : ajout d'ann√©e/mois/jours
                ~ myDate.minusYears(4) / minusMonths(15) / minusDays(35) : soustraction d'ann√©e/mois/jours
                ~ myDate.plus(Period)



    2Ô∏è‚É£ LocalTime ‚Äì Manipulation de l'heure uniquement
        Utilis√© quand seule l‚Äôheure est importante (sans date).

        Ex :
            import java.time.LocalTime;
            public class Main {
                public static void main(String[] args) {
                    // Heure actuelle
                    LocalTime now = LocalTime.now();
                    System.out.println("Heure actuelle : " + now);              // 14:45:10.123

                    // Heure sp√©cifique (heures, minutes, secondes)
                    LocalTime time = LocalTime.of(14, 30, 15);
                    System.out.println("Heure sp√©cifique : " + time);           // 14:30:15

                    // Ajouter/Soustraire des heures/minutes/secondes
                    LocalTime futureTime = now.plusHours(3);
                    LocalTime pastTime = now.minusMinutes(20);
                    System.out.println("Dans 3 heures : " + futureTime);        // 17:45:10.123
                    System.out.println("Il y a 20 minutes : " + pastTime);      // 14:25:10.123

                    // Comparaison d'heures
                    boolean isBefore = time.isBefore(now);
                    boolean isAfter = time.isAfter(now);
                    System.out.println("Est avant maintenant ? " + isBefore);   // true
                    System.out.println("Est apr√®s maintenant ? " + isAfter);    // false
                }
            }

            instanciation :
                ~ LocalTime.now() : cr√©er un temps d'aujourd'hui
                ~ LocalTime.of(19, 03, 14) : cr√©er un temps sp√©cifique (heure - minute - sec)
            methodes :
                ~ myTime.getHour() : r√©cup√©rer l'heure
                ~ myTime.getMinute() : r√©cup√©rer le minute
                ~ myTime.plusHours(4) / plusMinutes(15) / plusSecondes(35) : ajout 
                ~ myTime.minusHours(4) / minusMinutes(15) / minusSecondes(35) : soustraction 
                ~ myTime.plus(Duration) : ajout d'une dur√©e 


    3Ô∏è‚É£ LocalDateTime ‚Äì Combinaison de date et heure
        Utilis√© quand date + heure sont importantes ensemble.

        Ex :
            import java.time.LocalDateTime;
            public class Main {
                public static void main(String[] args) {
                    // Date et heure actuelles
                    LocalDateTime now = LocalDateTime.now();
                    System.out.println("Date et heure actuelles : " + now);                 // 2025-02-05T14:45:10.123

                    // Date et heure sp√©cifiques
                    LocalDateTime dateTime = LocalDateTime.of(2025, 2, 5, 14, 30, 15);
                    System.out.println("Date et heure sp√©cifiques : " + dateTime);          // 2025-02-05T14:30:15

                    // Ajouter/Soustraire du temps
                    LocalDateTime futureDateTime = now.plusDays(5).plusHours(2);
                    LocalDateTime pastDateTime = now.minusMonths(1).minusMinutes(30);
                    System.out.println("Dans 5 jours et 2 heures : " + futureDateTime);     // 2025-02-10T16:45:10.123
                    System.out.println("Il y a 1 mois et 30 minutes : " + pastDateTime);    // 2025-01-05T14:15:10.123
                }
            }

            instanciation :
                ~ LocalDateTime.now() 
                ~ LocalDateTime.of(someDate, someTime) : cr√©er un temps sp√©cifique (Annee - Mois - Jour - heure - minute - sec)
            methodes : tout les methodes de LocalDate et LocalTime

    5Ô∏è‚É£ Dur√©es et P√©riodes (Duration et Period)
        Period ‚Üí Dur√©e (jours, mois, ann√©es)

            Ex :
                import java.time.LocalDate;
                import java.time.Period;
                public class Main {
                    public static void main(String[] args) {
                        LocalDate startDate = LocalDate.of(2024, 1, 1);
                        LocalDate endDate = LocalDate.of(2025, 2, 5);

                        Period period = Period.between(startDate, endDate);

                        System.out.println("Diff√©rence : " + period.getYears() + " ans, " + 
                            period.getMonths() + " mois, " + period.getDays() + " jours");
                    }
                }

            methodes :
                ~ Period.of(03, 04, 06) : cr√©er un Dur√©e de 3ans, 4mois et 6j
                ~ Period.between(startDate, endDate) : cr√©er une dur√©e entre startDate et endDate


        Duration ‚Üí Dur√©e (heures, minutes, secondes)

            Ex :
                import java.time.Duration;
                import java.time.LocalTime;
                public class Main {
                    public static void main(String[] args) {
                        LocalTime startTime = LocalTime.of(10, 30);
                        LocalTime endTime = LocalTime.of(14, 45);

                        Duration duration = Duration.between(startTime, endTime);

                        System.out.println("Dur√©e : " + duration.toHours() + " heures, " + 
                            duration.toMinutes() % 60 + " minutes");
                    }
                }

            methodes :
                ~ Duration.ofHours(3).plusMinutes(30) : cr√©er une dur√©e de 03h30    // affiche PT03H30
                ~ Duration.between(startTime, endTime) : cr√©er une dur√©e entre startTime et endTime


    6Ô∏è‚É£ Timezones avec ZoneId et ZonedDateTime

        üìå ZoneId ‚Äì Repr√©sente un fuseau horaire
            ZoneId permet de d√©finir un fuseau horaire sp√©cifique (ex : "Europe/Paris", "GMT+3").

                import java.time.ZoneId;
                public class Main {
                    public static void main(String[] args) {
                        // Afficher le fuseau horaire par d√©faut
                        ZoneId defaultZone = ZoneId.systemDefault();
                        System.out.println("Fuseau par d√©faut : " + defaultZone);

                        // D√©finir un fuseau horaire sp√©cifique
                        ZoneId parisZone = ZoneId.of("Europe/Paris");
                        System.out.println("Fuseau horaire de Paris : " + parisZone);
                    }
                }

        üìå ZonedDateTime ‚Äì Manipuler une date/heure avec un fuseau horaire
            ZonedDateTime associe une date, une heure et un fuseau horaire.

                import java.time.ZonedDateTime;
                import java.time.ZoneId;
                public class Main {
                    public static void main(String[] args) {
                        // Date et heure actuelles avec fuseau par d√©faut
                        ZonedDateTime now = ZonedDateTime.now();
                        System.out.println("Date et heure actuelles : " + now);                 // 2025-02-06T14:45:10.123+01:00[Europe/Paris]

                        // Date et heure actuelles avec un fuseau horaire sp√©cifique
                        ZonedDateTime parisTime = ZonedDateTime.now(ZoneId.of("Europe/Paris"));
                        System.out.println("Heure de Paris : " + parisTime);                    // 2025-02-06T14:45:10.123+01:00[Europe/Paris]

                        // Convertir une LocalDateTime en ZonedDateTime
                        ZonedDateTime newYorkTime = parisTime.withZoneSameInstant(ZoneId.of("America/New_York"));
                        System.out.println("Heure de New York : " + newYorkTime);               // 2025-02-06T08:45:10.123-05:00[America/New_York]
                    }
                }


    7Ô∏è‚É£ Formatage des Dates (DateTimeFormatter)
                import java.time.LocalDateTime;
                import java.time.format.DateTimeFormatter;
                public class Main {
                    public static void main(String[] args) {
                        LocalDateTime now = LocalDateTime.now();

                        // D√©finir un format personnalis√©
                        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");

                        // Formater la date
                        String formattedDate = now.format(formatter);
                        System.out.println("Date format√©e : " + formattedDate);
                    }
                }

            -------------------------------------------------------
                Motif	Exemple	    Description
            -------------------------------------------------------
                yyyy	2025	    Ann√©e sur 4 chiffres
                yy	    25	        Ann√©e sur 2 chiffres
                MM	    02	        Mois sur 2 chiffres
                MMM	    F√©v	        Mois abr√©g√©
                MMMM	F√©vrier	    Mois en toutes lettres
                dd	    06	        Jour sur 2 chiffres
                HH	    14	        Heure (24h)
                hh	    02	        Heure (12h)
                mm	    45	        Minutes
                ss	    10	        Secondes
            -------------------------------------------------------



THREADS ---------------------------------------------------------------------------------------------------

    Java prend en charge le multithreading, permettant d'ex√©cuter plusieurs t√¢ches en parall√®le pour 
    am√©liorer les performances des applications.

    Un thread est un sous-processus l√©ger qui peut s'ex√©cuter ind√©pendamment. Par d√©faut, un programme 
    Java s'ex√©cute sur un thread principal appel√© main thread.
        import java.lang.Thread; 
        System.out.println("Thread principal : " + Thread.currentThread().getName());           // main

    Il existe trois fa√ßons principales de cr√©er un thread :

        1Ô∏è‚É£ En √©tendant Thread : On cr√©e une classe qui h√©rite de Thread et on red√©finit la m√©thode run().
            (Ne pas appeler run() directement, sinon il s‚Äôex√©cutera comme une m√©thode normale)

            class MonThread extends Thread {
                public void run() {
                    System.out.println("Ex√©cution du thread : " + Thread.currentThread().getName());
                }
            }

            MonThread thread1 = new MonThread();
            thread1.start();  // D√©marrer le thread > Thread-0
            

        2Ô∏è‚É£ En impl√©mentant Runnable (Best Practice ‚úÖ)
            class MonRunnable implements Runnable {
                public void run() {
                    System.out.println("Thread en cours d'ex√©cution : " + Thread.currentThread().getName());
                }
            }

            Thread thread2 = new Thread(new MonRunnable());
            thread2.start();

            ~ Thread.sleep(1000) => faire un pause de 1000ms


        3Ô∏è‚É£ Les "Executors" pour √™tre plus moderne (√âcrivez un code concurrent)	// java.util.concurrent
            - newSingleThreadExecutor(): la possibilit√© d'avoir un thread
            - newCachedThreadPool(): la possibilit√© d'avoir un thread dynamique
            - newFixedThreadPool(): la possibilit√© d'avoir un nombre fixe de thread (pour les traitement plus lent)


            ~ ExecutorService ex = Executors.newSingleThreadExecutor();
            ~ ExecutorService ex = Executors.newCachedThreadPool();
            ~ ExecutorService ex = Executors.newFixedThreadPool(4);             // 4 = nbr de threads 

				// Callable : un methode qui ne prend pas de param√®tre mais return un T	(java.util.concurrent.Callable)
                Runnable task = () -> {                 // expression lambda, Runneble ne renvoie rien	
                    ...
                }

                ex.execute(task);                       // executer task dans le "newSingleThreadExecutor"
                ex.shutdown();                          // Ferme l'executor apr√®s ex√©cution

            avec ExecutorService on peut:
                * fermer l'executor apr√®s ex√©cution avec shutdown()
                * avoir les resultats d'execution dans un variable de Type "Future" (java.util.concurrent)
                    Future<?> fut = executor.submit(task)       // <?> : g√©n√©rique (on ne sait pas quel type il r√©cup√®re)
                    ~ fut.isDone() => est fini (boolean)
                    ~ fut.isCanceled() => est annul√© (boolean)
                    ~ fut.get() => recup√©re les resultats
                    ~ fut.cancel() => annuler
                    
            Exemple concret: Construction de 10 blocs
        
			    Set<IBloc> blocs = new LinkedHashSet<IBloc>();
			    ExecutorService executorService = Executors.newFixedThreadPool(10);
			    
			    Callable<IBloc> taskMur1 = () -> { return new Mur(3, 2, 2, true); };
			    Callable<IBloc> taskMur2 = () -> { return new Mur(2, 1, 2, false); };
			    Callable<IBloc> taskPorte = () -> { return new Porte(1, 2, 2, true); };
			    Callable<IBloc> taskToit = () -> { return new Toit(3, 1, 1); };
			    
			    List<Callable<IBloc>> tasks = Arrays.asList(taskMur1, taskMur1, taskMur2, taskMur2, taskPorte, 
			    											taskToit, taskToit, taskToit, taskToit, taskToit);
			    try {
			        List<Future<IBloc>> resultas = executorService.invokeAll(tasks);
			        resultas.forEach((resultat) -> {
			        try {
			            blocs.add(resultat.get());
			        } catch (InterruptedException | ExecutionException e) {
			            logger.error("Erreur lors de cr√©ation parall√®le des blocs.");
			        }
			        });
			    } catch (InterruptedException e) {
			        logger.error("Erreur lors de cr√©ation parall√®le des blocs.");
			    }
			    executorService.shutdown();
			    
			    // si une cr√©tion prend 1s : au lieu d‚Äôenviron 10 secondes, le code met environ 1 seconde √† s‚Äôex√©cuter
			    
		NB: Depuis la version 19 de Java, pour affronter les probl√®mes de concurrence, les Virtual Thread sont √† votre disposition.
			(celle en dessus, on va l'appeler Platform Thread)
			(il faut juste cahnger newFixedThreadPool() par newVirtualThreadPerTaskExecutor() et on import dans l'exemple pr√©c√©dent)
			
			----------------------------------------------------------------------------------------------
								Gestionnaire du Thread			Cons√©quence
			----------------------------------------------------------------------------------------------
			Platform Thread		Syst√®me d‚Äôexploitation			Sollicite directement l‚ÄôOS donc plus lourd
			Virtual Thread		JVM								Ne sollicite pas l‚ÄôOS et donc plus l√©ger.		// rapide √† l'ecriture
			----------------------------------------------------------------------------------------------


DASE DE DONNEES ---------------------------------------------------------------------------------------------------

    JDBC est l'API standard de Java pour interagir avec une base de donn√©es relationnelle (comme MySQL, 
    PostgreSQL, Oracle, etc.). Elle permet aux applications Java d‚Äôex√©cuter des requ√™tes SQL et de manipuler 
    les donn√©es.


    Pour interagir avec une base de donn√©es via JDBC, il faut suivre ces 5 √©tapes :
        - Charger le Driver JDBC : mettre un pilote dans le classpath pour permettre √† Java de communiquer 
                                    avec une base de donn√©es (en g√©n√©ral .jar )
            et mettre :
                Class.forName("org.sqlite.JDBC")        // si c'est une base SQLite
        - √âtablir une Connexion : On utilise "DriverManager" pour √©tablir une connexion avec la base de donn√©es (dans java.sql)
            Connection co = DriverMananager.getConnection()
            * SQLite => getConnection("jdbc:sqlite:path\\to\\db.sql");
            * MySQL => getConnection("jdbc:mysql://localhost:3306/dbname?useSSL=false", "user", "pass");
        - Ex√©cuter des Requ√™tes SQL : On utilise "Statement" pour ex√©cuter des requ√™tes SQL et "ResultSet" 
        pour stoquer les resultats de la requ√™te.
            => Statement stmt = conn.createStatement();
            => ResultSet rs = stmt.executeQuery("SELECT * FROM products");
            s'il n'y a pas de resultat √† recuperer (DELETE, UPDATE,...)
            => stmt.executeUpdate(...)      
        - Utiliser PreparedStatement : pour plus de S√©curis√© (par ex, s'il y de donn√©es des utilisateur ou exterieur √† entrer) ‚úÖ
            PreparedStatement stmt = conn.prepareStatement("UPDATE products SET product_name = ? WHERE product_id = ?");    // ? = Joker
            stmt.setString(1, "Jores");             // 1 = 1er joker
            stmt.setInt(2, 23);                     // 2 = 2e joker
            stmt.executeUpdate();                   // s'il n'y a pas de resulatat a recuperer sinon on fait un ResultSet avec executeQuery()
        - Fermer la Connexion 

NB : 
     - SQLite est un base de donn√©es portable, embarqu√©e directement dans le projet sans connection √† distant
     - Il faut Configurer le classpath:
        Ouvrez le fichier ".vscode/settings.json" de votre projet et ajoutez le chemin vers le fichier JAR. 
        Inserer cet code de configuration :
        {
            "java.project.referencedLibraries": [
                "lib/**/*.jar",
                ou
                "path/to/your/sqlite-jdbc-version.jar"
            ]
        }
     - certains drivers JDBC peuvent se charger automatiquement et s'enregistrer sans avoir besoin de 
        l'appeler explicitement dans Class.forName()
     - faire un "while (rs.next())" pour boucler sur tout les resultats trouver sur la r√©qu√™te ("SELECT * FROM products")
        sinon il va faire les actions (par exemple : getString()) sur le pr√©mier resultat trouver (comme first)


        ~ rs.getString("product_name) => R√©cuperer le champ "product_name" de la table "products" (getInt, getDouble,...)
        ~ 



JURNALISATION (LOGGING) --------------------------------------------------------------------------------------------

	La journalisation (logging) est une technique essentielle en Java pour enregistrer des messages sur l‚Äô√©tat d‚Äôune 
	application, d√©tecter des erreurs, surveiller son ex√©cution, et faciliter le d√©bogage.
	Au lieu d‚Äôutiliser System.out.println(), qui n‚Äôest pas flexible ni performant, Java propose des biblioth√®ques 
	sp√©cialis√©es comme :
		* java.util.logging (JUL) (API int√©gr√©e √† Java)
		* Log4j (Apache Log4j)
		* SLF4J (Simple Logging Facade for Java)
		* Logback (recommand√© avec Spring Boot)
	
	Pourquoi utiliser un Logger
		‚úÖ Diff√©rents niveaux de log (INFO, DEBUG, ERROR, etc.)
		‚úÖ Possibilit√© de rediriger les logs vers des fichiers, la console, une base de donn√©es, etc.
		‚úÖ Am√©liore la maintenabilit√© et le d√©bogage
	
	Le concept consiste en l‚Äôassociation d‚Äôune trace avec un niveau. Ensuite lors de l‚Äôex√©cution de l‚Äôapplication le niveau 
	de log √† utiliser est d√©fini. Toutes les traces associ√©es √† ce niveau et au niveau sup√©rieur sont utilis√©es.
		
	Voici un exemple de niveaux de log :
		Le niveau OFF sera donc celui √† appliquer pour les utilisateurs finaux o√π nous ne voulons voir aucune trace.
		Le niveau ALL est son extr√™me oppos√©, il est le plus verbeux et affiche la moindre trace disponible ! 

		---------------------------------
		Nom du niveau	Valeur du niveau
		---------------------------------
		OFF				0
		FATAL			100
		ERROR			200
		WARN			300
		INFO			400
		DEBUG			500
		TRACE			600
		ALL				Integer.MAX_VALUE
		---------------------------------

	NB : - En fonction de la biblioth√®que de Logging les niveaux peuvent varier.
		 - Un fichier JAR est une archive contenant plusieurs fichiers java compil√©s
	
	Installation la biblioth√®que Log4J en v2 (log for J)
		1 - la biblioth√®que Log4J doit √™tre t√©l√©charg√©e ici : 
			https://logging.apache.org/log4j/2.x/download.html > la version binary.zip
		2 - ajouter les fichiers jar au projet:
			extraire le fichier zip t√©l√©charger
			dans Eclipse clic droit sur le projectname > Build Path > Configure Build Path
			dans le fenetre qui s'ouvre > Librairies > Modulepath > Add External JARs
			allez dans le fichier t√©l√©charger (d√©j√† extrait) > apache-log4j-version-bin
			selectionner log4j-api-version.jar et log4j-core-version.jar
			Apply and Close
			Verifier les librairies dans Package Explorer > Projectname > Raferenced Librairies
			
	Utilisation de la biblioth√®que Log4J
		1 - Cr√©er le fichier projectname/src/log4j2.properties
			rootLogger = ERROR, STDOUT¬∑							// les logs de la racine sont associ√© a niveau ERROR
			
			loggers = ej.bloc									// cr√©er un autre log associ√© au package projetctname.bloc
			logger.ej.bloc.name = ej.bloc						// affecter un nom au logger projetctname.bloc
			logger.ej.bloc.level = INFO							// affecter un nineau au logger projetctname.bloc
			
			appender.console.name = STDOUT						// cr√©er un apppender dans la console
			appender.console.type = Console
			appender.console.layout.type = PatternLayout
			appender.console.layout.pattern = [%-5level] %d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %c{1} - %msg%n		// model de l'affichage

		2 - ajouter des traces
			cr√©er un variable priv√©e dans la classe de type org.apache.logging.log4j.Logger :
				private static Logger logger = LogManager.getLogger(Bloc.class);
			utiliser dans la classe m√™me
				logger.info("ma trace‚Ä¶");						// selon le niveau accepter dans la fichier "log4j2.properties"
		
DEVOIR : voir la documentation (https://logging.apache.org/log4j/2.x/manual/appenders.html) de log4j2 
		car si je cr√©e "projectname/src/log4j2.properties" √ßa marche pas mais si je ne le cr√©e pas, 
		le log s'affiche normalement dans la console
		
	Voici quelques bonnes pratiques :
		Chaque classe doit avoir sa propre instance de Logger.
		Les traces doivent √™tre dat√©es.
		Les niveaux de logs doivent √™tre d√©finis en fonction des packages.
		Les traces ne doivent pas polluer l‚Äôutilisateur final. 
		La configuration du logging doit √™tre externalis√©e dans un fichier pour pouvoir la modifier √† 
			chaud sans avoir √† red√©marrer l‚Äôapplication.
		Aucune information sensible (comme un mot de passe) ne doit √™tre dans les traces.
	
	

-------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------

Paradigme et paradigme de programmation ?
	-Un paradigme est une fa√ßon de voir le monde et ses probl√®mes.
	-Un paradigme en programmation est une mani√®re d'√©crire et visualiser le code. Il s'agit d'un style 
	 de programmation qui d√©finit la fa√ßon dont le programme est structur√© et ex√©cut√©.
	ex : la programmation orient√©e objet, la programmation imp√©rative, la programmation d√©clarative,
		 programmation fonctionnelle
	- Un langage est sp√©cialis√© dans un paradigme mais il peut utiliser d'autre avec plus ou moins de 
	 difficult√© et un r√©sultat plus ou moins efficace.
	 
	Programmation imp√©rative : 
		Description du "comment" : La programmation imp√©rative se concentre sur la description pr√©cise 
									des √©tapes √† suivre pour atteindre un r√©sultat. Le d√©veloppeur sp√©cifie 
									comment le programme doit s'ex√©cuter, en donnant des instructions d√©taill√©es.
		Modification de l'√©tat : Les programmes imp√©ratifs modifient l'√©tat du programme en manipulant 
									des variables et en ex√©cutant des instructions s√©quentielles.
		Exemples : C, Java, Python (dans une certaine mesure).

	Programmation d√©clarative
		Description du "quoi" : La programmation d√©clarative se concentre sur la description du r√©sultat 
								souhait√©, sans pr√©ciser comment l'atteindre. Le d√©veloppeur d√©clare ce qu'il 
								veut obtenir, laissant le langage ou l'environnement d'ex√©cution d√©terminer 
								les √©tapes √† suivre.
		Abstraction des d√©tails d'impl√©mentation : Les programmes d√©claratifs sont plus abstraits et se 
								concentrent sur la logique de haut niveau plut√¥t que sur les d√©tails d'impl√©mentation.
		Exemples : SQL, HTML, CSS, Prolog.

NB : G√©n√©ral
    * La JVM fait partie du Java Runtime Environment (JRE). Pour ex√©cuter un programme Java, 
        il suffit d'installer le JRE appropri√© √† votre plateforme. Les d√©veloppeurs utilisent 
        souvent le Java Development Kit (JDK), qui inclut le JRE ainsi que les outils n√©cessaires 
        pour √©crire et compiler le code Java.
    * C'est le syst√®me d'exploitation (avec le JVM : Java Virtual Machine) qui g√®re 
        automatiquement notre m√©moire. On ne peut pas choisir manuellement o√π √† quel adresse 
        m√©moire on veut stoker un variable
    * La JVM est une couche d'abstraction qui permet √† Java d'√™tre portable, performant et s√©curis√©. 
        Sans elle, Java ne serait pas aussi universel et polyvalent. C'est elle qui traduit le bytecode (.class)
        ind√©pendant en instructions sp√©cifiques √† votre machine, tout en g√©rant des aspects complexes 
        comme la m√©moire et la s√©curit√©.
	* Java est un langage compil√©, langage typ√©, langage objet.
        
	* En Java, le nom d‚Äôune classe doit toujours commencer par une majuscule. Le nom du fichier Java 
		doit correspondre au nom de la classe.
	
    * Tout les type primitive java non initialis√© ont des valeurs par d√©faut (int = 0, char = "", ...)
    * Tout les objets java  non initialis√© (Array, String, objet d'une classe,...) ont des valeurs par d√©faut = null
    * on ne fait pas d'import  si :
    	- on utilise des classe dans le m√™me paquage
    	- on utilise des classe dans le paquage java.lang
        
    * Tout les objets java (Array, String, objet d'une classe,...) h√©rite du classe "Object"
        et peuvent utiliser ses m√©thodes comme : equals, toString 

    * Monothread : utilise 1 seul thread ou fil d‚Äôex√©cution           // StringBuilder 
    * Multithread : utilise plusieurs thread ou fil d‚Äôex√©cution       // StringBuffer

    * Les concepts de monothreading/multithreading et synchrone/asynchrone sont li√©s mais DIFFERENT.
    Le monothreading/multithreading concerne l'ex√©cution de plusieurs t√¢ches et le nombre de threads. 
    Le synchrone/asynchrone concerne l'ex√©cution d' une seule t√¢che et l'attente ou non de son r√©sultat. 
    Comprendre cette diff√©rence est crucial pour concevoir des applications performantes et r√©actives.
    * NB : souvent on utilise le monothreading pour une question de performance. 

	* les 05 signatures d'une foction sont :
		- visibilit√© : Cet √©l√©ment influence les zones de code qui seront en droit d‚Äôex√©cuter la fonction.
		- caract√©ristique : Le comportement d‚Äôune fonction peut √™tre alt√©r√© par cet √©l√©ment. Plusieurs mots-cl√©s 
							Java sont applicables ici comme final ou static.
		- type retour : Comme le langage Java est typ√© il faut d√©finir √† l‚Äôavance quel type de donn√©e sera renvoy√©.
		- nom : Le nom sera utilis√© pour ex√©cuter la fonction au moment voulu.
		- param√®tres : Une fonction peut recevoir des donn√©es en entr√©e. Ces donn√©es seront alors exploit√©es 
						durant le traitement.
						
	* Java ne permet pas de mettre de valeur par d√©faut aux param√®tres des m√©thodes. 
		Le m√©canisme de surcharge permet de r√©soudre ce point comme le montre l‚Äôexemple pr√©c√©dent.
	
	* Les techniques de programmation (variable, fonction, condition, it√©ration) appartiennent au paradigme de la
		programmation structur√©e . Ce paradigme est une base pour de nombreux langages de programmation qui est 
		diff√©rent du langage objet.
		
    * si on veut d√©placer un fichier ou modifier des choses (comme le nom du package, les import,...) dans java, 
        il faut supprimer le bytecode(.class) et le recompiler 

    * les erreurs dans le console s'appelle les "Piles d'erreurs" (ce sont des informations d'erreurs qui s'empilent) 

    * il faut toujours mettre dans le bloc try-catch les methodes qui peuvent d√©clencher une exception

    * L'√©poque Java : un point de r√©f√©rence universel
        C'est d√©finie comme le 1er janvier 1970 √† 00h00 UTC (Temps Universel Coordonn√©). C'est un point de r√©f√©rence 
        temporel standard √† partir duquel sont calcul√©es toutes les autres dates et heures en Java.

    * (important) Les classes dans un package ne peuvent pas directement acc√©der aux classes du package par d√©faut (classe n'a pas de package).
    
    * V√©rifier qu'un comportement qui √©tait fonctionnel l‚Äôest toujours apr√®s une modification s‚Äôappelle un test de non-r√©gression.
    * Une trace ou un log en anglais est une information issue de l‚Äôex√©cution du code de l‚Äôapplication. 




QUELQUE METHODE UTILES ---------------------------------------------------------------------------

        Random random = new Random();
        int randomNumber1 = random.nextInt();		// G√©n√®re un nombre entier pseudo-al√©atoire
        int randomNumber2 = random.nextInt(10);		// G√©n√®re un nombre entier pseudo-al√©atoire compris entre 0 (inclus) et 10 (exclus)
        // c'est les m√™me dans nextBoolean(), nextDouble(), nextLong(), nextFloat()
        
		byte[] byteArray = new byte[10];
		random.nextBytes(byteArray);				// G√©n√®re un tableau de bytes al√©atoires
        


CONTEXT MENU DES EXTENSIONS JAVA VSCODE ---------------------------------------------------------------------------


    ----------------------------------------------------------------------------------------------------
    Option	                        Quand l'utiliser ?
    ----------------------------------------------------------------------------------------------------
    Evaluate in Debug Console	    Pendant le d√©bogage pour tester des expressions.
    Add Inline Breakpoint	        Pour arr√™ter l'ex√©cution √† une ligne sp√©cifique.
    Add to Watch	                Pour suivre une variable pendant l'ex√©cution.
    Run to Cursor	                Pour ex√©cuter jusqu'√† une ligne o√π il y a le curseur.
    Run Java	                    Pour ex√©cuter un fichier Java rapidement.
    Run Project                     Without Debugging	Pour ex√©cuter tout le projet sans interruption.
    Debug Java	                    Pour d√©boguer un seul fichier.
    Debug Project	                Pour analyser tout le projet en mode d√©bogage.
    ----------------------------------------------------------------------------------------------------


1. Evaluate in Debug Console
    Description :
        - Cette option est disponible lorsque vous √™tes en mode d√©bogage.
        - Elle vous permet d'√©valuer une expression ou une ligne de code directement dans la console de d√©bogage.
    Utilit√© :
        - Par exemple, si vous voulez v√©rifier la valeur d'une variable ou ex√©cuter une m√©thode pendant l'ex√©cution du programme.


2. Add Inline Breakpoint (Raccourci : Shift+F9)
    Description :
        - Ajoute un point d'arr√™t directement sur la ligne de code o√π vous cliquez.
        - Cela permet au d√©bogueur de s'arr√™ter √† cet endroit lors de l'ex√©cution.
    Utilit√© :
        - Utile pour examiner les valeurs des variables ou comprendre le flux du programme √† des √©tapes sp√©cifiques.
        - Les points d'arr√™t sont essentiels pour d√©boguer un programme.


3. Add to Watch
    Description :
        - Ajoute une variable ou une expression √† la liste de surveillance dans le panneau de d√©bogage.
        - La liste de surveillance vous permet de suivre les changements de valeur de cette variable pendant l'ex√©cution du programme.
    Utilit√© :
        - Pratique pour surveiller des variables importantes et voir leur √©volution sans avoir √† les rechercher dans le code.


4. Run to Cursor
    Description :
        - Lance le programme en mode d√©bogage et s'arr√™te √† la ligne o√π le curseur est positionn√©.
    Utilit√© :
        - Permet d'ex√©cuter le programme rapidement jusqu'√† une section sp√©cifique sans avoir √† ajouter un point d'arr√™t.


5. Run Java
    Description :
        - Ex√©cute uniquement le fichier Java s√©lectionn√©, sans aucun d√©bogage.
    Utilit√© :
        - Simplement pour tester un fichier ou ex√©cuter un programme rapidement sans v√©rifier les erreurs ou comportements d√©taill√©s.


6. Run Project Without Debugging
    Description :
        - Ex√©cute l'int√©gralit√© du projet Java sans activer le mode d√©bogage.
    Utilit√© :
        - Utile pour voir si le projet fonctionne correctement de bout en bout sans interruptions dues aux points d'arr√™t.


7. Debug Java
    Description :
        - Lance le fichier Java s√©lectionn√© en mode d√©bogage.
        - Le programme s'arr√™te automatiquement √† tous les points d'arr√™t configur√©s.
    Utilit√© :
        - Id√©al pour identifier les bugs ou analyser le comportement de sections sp√©cifiques du fichier.


8. Debug Project
    Description :
        - D√©bogue l'ensemble du projet Java (et non seulement le fichier actuel).
        - Cela inclut tous les fichiers n√©cessaires √† l'ex√©cution, ainsi que les d√©pendances externes.
    Utilit√© :
        - Recommand√© si votre projet Java comporte plusieurs fichiers ou classes interconnect√©s, et que vous souhaitez d√©boguer le comportement global.




---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
-------------------------  CONTEXTE DEVOPS : OUTILS ET LEURS R√îLES  -------------------------------------
---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------

    Git : Gestion du versioning du code source (suivi des modifications, collaboration).
    Maven / Gradle : Automatisation des builds (compilation, tests, packaging).
    Docker : Cr√©ation de conteneurs d'applications (encapsulation et portabilit√©).
    Kubernetes : Orchestration des conteneurs (d√©ploiement, mise √† l'√©chelle, gestion).
    Jenkins : Automatisation des pipelines CI/CD (int√©gration et d√©ploiement continus).
    JUnit : Tests unitaires (v√©rification du bon fonctionnement du code).
    Cycle de vie d'un build Maven : Commandes et actions

    mvn compile : Compile le code source Java (.java ‚Üí .class). Sortie : target/classes.
    mvn test : Ex√©cute les tests unitaires. Sortie : target/surefire-reports.
    mvn package : Cr√©e un package distribuable :
    .JAR : pour les applications Java standard.
    .WAR : pour les applications web. Sortie : target.
    mvn install : Installe le package dans le d√©p√¥t local Maven (~/.m2/repository).
    mvn deploy : D√©ploie le package dans un d√©p√¥t distant (ex: serveur d'entreprise, Maven Central).
    mvn site : G√©n√®re la documentation du projet.

Tableau r√©capitulatif :
----------------------------------------------------------------------------------------------------
Commande Maven	    Action	                                R√©pertoire de sortie (principal)        |
----------------------------------------------------------------------------------------------------|
    mvn compile	    Compilation du code source Java	        target/classes                          |
    mvn test	    Ex√©cution des tests unitaires	        target/surefire-reports                 |
    mvn package	    Cr√©ation du package (JAR ou WAR)	    target                                  |
    mvn install	    Installation du package dans            ~/.m2/repository                        |
                    le d√©p√¥t local	                                                                |
    mvn deploy	    D√©ploiement du package dans un          D√©p√¥t distant                           |
                    d√©p√¥t distant	                                                                |
    mvn site	    G√©n√©ration de la documentation          target/site                             |
                    du projet	                                                                    |
----------------------------------------------------------------------------------------------------

