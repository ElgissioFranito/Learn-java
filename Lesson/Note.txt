INTRODUCTION ------------------------------------------------------------------------------------------------------

class MainApp {
    public static void main(String[] args) {
        System.out.println("Bonjour tout le monde ! :)");
    }
}


---------------------------------------------------------------------------------------
Type        Type "Objet"    Place en        Fourchette de 
Primitif	Associé	        Mémoire	        Valeurs (Min & Max)
---------------------------------------------------------------------------------------
boolean	    Boolean	        1 octet	        true (1), false (0)
byte	    Byte	        1 octet	        -128 à 127
char	    Character	    2 octets	    Unicode (65536 caractères disponibles)
short	    Short	        2 octets	    -32768 à 32767
int	        Integer	        4 octets	    -2 147 483 648 à 2 147 483 647
long	    Long	        8 octets	    -2<sup>63</sup> à +2<sup>63</sup>-1
float	    Float	        4 octets	    1.4x10<sup>-45</sup> à 3.4x10<sup>38</sup>
double	    Double	        8 octets	    4.9x10<sup>-324</sup> à 1.7x10<sup>308</sup>
---------------------------------------------------------------------------------------

Notation d'un nombre :
    * 14 
    * 18056
    * 1_128_8531_876 (avec un séparateur de millier pour la lisibilité)


Base numérique : (on peut le fais dans n'importe quel type même String)
    * décimale (10 => 0 à 9) : 0b110101110  (préfixé par 0b____ ou \b) 
    * binaire (2 => 0 et 1) : 110_101_110
    * octale (8 => 0 à 7) : 0755            (préfixé par 0____ ou \)
    * hexadécimale (16 => 0 à F) :0xAF45    (préfixé par 0x____ ou \x)


caractères spéciaux : 
    \n : nouvelle ligne
    \t : tabulation
    \r : retour chariot
    \b : retour arrière
    \f : nouvelle page


FLUX DE CONTROLE ------------------------------------------------------------------------------------------------------

Les conditions on peut l'écrire sans les accolades sur une seule ligne
    if (value == 24 || value == 16) 
        System.out.println("Oui !"); 
    else if(value == 14)
        System.out.println("value ne vaut 14");
    else
        System.out.println("value ne vaut ni 24 ni 16 ni 14");
        
Le "switch" peut etre écris comme ceci :
	public static String categorieDeFilm(final String film) {
	    var resultat = switch(film) {									// le resultat de switch vont directement dans "resultat"
	        case "Star Wars" -> "Science fiction";
	        case "Blanche neige", "La petite sirène" -> "Disney";
	        case "Indiana Jones" -> {									// bloc en plusieurs lignes
	            String categorie = "Aventure";
	            yield categorie;										// yield => "categorie" est retourné par le switch mais pas par la fonction
	        }															// uniquement depuis Java 14
	        default -> "Inconnu";
	    };
	    return resultat;
	}
        
Le structures itératives = boucle
	public static void main(String[] args) {
	    List<String> languageNames = Arrays.asList("Java", "PHP", "JavaScript");
	    for (String language : languageNames) {
	        System.out.println(language);
	    }
	}

CLASSE ------------------------------------------------------------------------------------------------------

NB : 
    * On ne peut pas créer un projet java sans une Classe
    * 1 classe = 1 fichier
    * Les propriétés d'une classe est "private" par défaut si on ne me pas de porté
    * les methodes d'une classes est "private" par défaut si on ne met pas de porté
    * On peut déclarer des méthodes de même nom si ils n'on pas les 
        même signatures (arguments, type d'arguments, type de retour)
        Ça s'appelle le "Surcharge de méthode"				// polymorphisme à la compilation

    * le "constructeur" porte le nom du classe et n’a pas de type retour   
        public class Person {
            public Person() {                           // Constructor
                System.out.println("Person created");
            }
        }

    * on met la methode "static" pour les classes qu'on ne veut pas instancier
        par exemple dans la méthode "main"

    * Les valeur par défauts des arguments ne fonctionne pas en java
        public static String sayHello(String name, int NbSister = 1) {          // NO
            return "Hello " + name + " ! You have " + NbSister +" sisters";
        }
        (Sinon on peut simuler avec le surcharge de methodes en créant plusieurs 
        methode de même nom)								// polymorphisme à la compilation


Accesseurs : (encapsulation de données)
    # getters : récupération d'un propriété "private" d'une classe (lecture) et d'y ajouter une logique.
        public String getName() {
            return name != null ? name.toUpperCase() : "Nom non défini";
        }

    # setters : modification d'un propriété "private" d'une classe (écriture) et d'y ajouter une logique.
        public void setName(String name) {
            if (name != null && !name.isEmpty()) {
                this.name = name;
            } else {
                throw new IllegalArgumentException("Nom invalide");
            }
        }



Variable de Classe :
    private static int maxSoftware = 2;
    public Software(String licence) {
        if (maxSoftware > 0) {
            this.licence = licence;
            maxSoftware--;
        } else {
            System.out.println("Limite atteinte pour creer des logiciels");               
        }
    }


VARIABLE ------------------------------------------------------------------------------------------------------

Déclaration de variable : 
    int tab[] = new int[3];     // reserver en mémoire 3 adresse de suite (length = 3)
    int[] tab1, tab2            // tous les variables sont des tableaux
    int tab1[], tab2            // seul tab1 est un tableau

    int[] tab = { 81, 25, 37 };             // OK
    int[] tab = new int[3]{81,25,37};       // OK

    System.out.println(tab);                // affiche l'adresse mémoire du tab               
    System.out.println(tab[0]);             // affiche le valeur du 1er element du tab      

    * le Foreach ou le parcours d'un tableau 
        for (int element : tabX) {             
            System.out.println(element);
        }       

    * Le tableau à deux dimensions
        int[][] tab = new int[2][3];        => tableau à 2 lignes et 3 colonnes
        int[][] tab = {{ 81, 25, 37 }, { 81, 25, 37 }};  

    parcours tableau à deux dimensions:
        for(int i = 0; i < tab.length; i++) {
            for(int j = 0; j < tab[i].length; j++) {
                System.out.println(tab[i][j]);
            }
        }

STRING ------------------------------------------------------------------------------------------------------

STRING : immuable (Contenue non-modifiable) => le système détruit l'ancien adresse et
            crée un nouveau String sur un nouveau adresse (même les methodes toUpperCase(), trim(),...)
    * instanciation de type de l'objet String
        String chaine1= "Hello"
        String chaine2= new String("world")

NB : les caractères misent dans un simple guillemet sont de type "char" non pas String

    * methode utiles : 
        - concat()
        - length() => la longueur du String
        - toUpperCase(), toLowerCase()            
        - trim() => enlève les espaces au début et à la fin
        - replace("a","o")  => remplace les "a" en "o"
        - charAt(0) => récupère le caractère au 1er position
        - substring(1, 3) => récupérer 3 caractère à partir du l'indice 1 (2è caractère)
        - equals(chaine) => on ne peu pas comparer comme ceci (chaine1 == chaiine2) deux chaines 
        - replaceAll("/", " ") => remplacer tous les "/" en espace " "
        - maString.split ("-") => construire un tableau de String en le séparant la chaine "maString" quand il voit "-" 
        
        Exemples :
            String str3 = "See/you/soon";
            System.out.println(str3.replaceAll("/", " "));
            String[] tokens = str3.split("/");
            for (String token : tokens) {
                System.out.println(token);
            }

    * concatenation
        String ch = chaine1 + " " + chaine2                 // plus lourd en mémoire
        String ch = chaine1.concat(" ").concat(chaine2)     // plus léger, plus rapide

    * le StringBuilder / StringBuffer => immuable (Contenue modifiable) pas comme l'Objet string
        et ils ont le même fonctionnement et meme utilisation
        StringBuilder maString = new StringBuilder();

        - length(), capacity()
        - append(<str>) => c'est comme la méthode "push" avec les array
        - insert(<index>, <string>) => insérer une chaîne dans un position spécifique


PACKAGE ------------------------------------------------------------------------------------------------------
        
Création d'un package:
    - Créer un fichier nompackage/NomFichier.java (nom de package : miniscule, nom de fichier : pascal case)
    - insérer au debut de ligne le nom de package (comme le namespace) et on crée un classe classique
    - s'il y a plusieurs dossier imbriquer, on le sépare par un point
        ex : com/weapons/Knife.java
            package com.weapons;
            public class Knife {
                public Knife() {
                    System.out.println("Knife instancié !");
                }
            }
    - Remarque : souvient toujours de mettre bien la portée de classe, des methodes et des propriétés (public,...)

Import du package :
    - Dans un autre Classe qui l'utilise, on l'import depuis son nom de package (nompackage.NomClass)
        Remarque : ici on import bien avec son nom de classe mais pas son nom de fichier.
    - si le package est dans le même dossier (parfois), on n'a pas besoin de l'importer  
    - si on veut inclure tous les classes d'une package, on utilise le symbole étoile "*" (import nompackage.*;)
        ex : src/main.java
            import com.weapons.Knife;          // import la classe
            public class Main {
                public static void main(String[] args) {
                    Knife weapon1 = new Knife();
                }
            }
            
 	NB : - il faut mettre "public" devant un classe ou un methode (surtout le constructeur) pour qu'un
 			autre fichier java dans un autre package peut l'utiliser (ex: Main.java)

    
LECTURE AU CLAVIER ------------------------------------------------------------------------------------------------------

    - BufferedReader : lecture de données en string (multithread)       // plus rapide
    - Scanner : lecture + parsing (int,float,...) (monothread)          // plus lent même si monothread    

    * BufferedReader(<classReader>) : il a besoin de classe de lecture parc'il ne sait pas par défaut où est
            ce qu'il va lire (les périphérique d'entrée, un flux, un filchier,...) 
        import java.io.BufferedReader;
        import java.io.InputStreamReader;                               // un flux d'entrée

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    
        System.out.print("Quel est votre nom ? ");
        String name = br.readLine();
    
        - readLine() => lire tous les chaines de caractère (sans à la ligne "\n")  

        NB : il faut rendre la classe en "throws Exception" pour gérer les erreur en cas où 
            il ne peut pas lire les entrées SINON la classe ne se compile pas
            ex : public static void main(String[] args) throws Exception 

    * Scanner(<FluxLecture>) : il n'a besoin de classe de lecture mais juste un flux de lecture (System.in, System.out)
        import java.util.Scanner;

        Scanner sc = new Scanner(System.in);
        
        System.out.print("Quel est votre age ? ");
        int age = sc.nextInt();
        System.out.println("Vous avez " + age + " ans ");
        sc.close();
    
        - nextLine() => lire tous les chaines entrée (sans à la ligne "\n")  
        - nextInt() => lire tous les chaines entrée + parseInt
        - nextChar() => lire tous les chaines entrée + parseChar
        - nextByte() => lire tous les chaines entrée + parseByte
        - nextInFloat() => lire tous les chaines entrée + parseFloat
        - nextBoolean() => lire tous les chaines entrée + parseBoolean

        NB : 
            * pas besoin "throws Exception"  


EXCEPTION ------------------------------------------------------------------------------------------------------

    Try {
        System.out.print("Quel est votre age ? ");                      // 1 seul block "try"
        int age = sc.nextInt();
        System.out.println("Vous avez " + age + " ans ");
    }
    catch (NomException1 e) {                                           // s'execute si NomException1 se produit
        System.out.println("age n'est pas un nombre");
    }
    catch (NomException2 e) {                                           // s'execute si NomException2 se produit
        System.out.println("age trop grand");
    }
    catch (Exception e) {                                               // s'execute si un exception en général se produit
        System.out.println("il y a une exception!");
    }
    finaly {
        System.out.println("cet text s'affiche s'il y a une exception ou pas");
    }
    
    NB: - L’exception NullPointerException est couramment nommée NPE par les développeurs Java.
		- NPE se prosuit quand on exécute une méthode sur une variable qui vaut null.
		- Ce type de message s’appelle en anglais “stack trace”, cela donne la trace entre l’endroit où l’erreur a eu lieu 
			et le point d’entrée du programme :	
				Exception in thread "main" java.lang.NullPointerException: Cannot invoke "java.util.Set.size()" because 
				the return value of "ej.Kit.getMotsCles()" is null
				at firstproject.Main.main(Main.java:8)
		- Le mot-clé "throw" sans "s" suivi de l’instanciation d'une sorte d'Exception permet de lever l’exception.
				 throw new IllegalArgumentException();
		- Java nous contraint à ajouter à la signature de la méthode l’information : throws Exception		// avec s
				Bloc(final int hauteur) throws IllegalBlocException {
				    if(hauteur < MIN_HAUTEUR) {
				        throw new IllegalBlocException();
				    }
		- si c'est sur un constructeur, tous les constructeurs des classes filles doivent également 
			ajouter throws IllegalBlocException à leur signature.
		- De plus, le code de la classe Main sera obligé :
				* soit de mettre un try catch autour de l’appel du constructeur.
				* soit de mettre un throws IllegalBlocException à la méthode main pour qu’elle redirige à son tour cette exception.
		- RuntimeException et ses classes filles ont le droit à un traitement particulier en ce sens que nous 
			n'avons pas besoin de spécifier dans la signature de la méthode (comme RuntimeException et IllegalArgumentException)

HERITAGE ------------------------------------------------------------------------------------------------------

NB : 
    - toute les classes hérite de la classe "Object"
    - la porté "protected" rend une propriété parent accessible uniquement par ces enfants et petit-enfants
    - "extends" rend une classe enfant d'une autre classe 
    - la methode super() veut dire utiliser le constructor de la classe parent
    - la super.move() veut dire utiliser le methode "move()" de la classe parent
    - les enfants peut utiliser les methodes de la classe supérieur
    - en java, une classe ne peut pas hérité de plusieurs parents (héritage multiple )
    - Une instance d’une classe fille peut être affectée à une variable typée par la classe mère   
    	Horse unChaval = new Pegasus();   						// l'inverse n'est pas possible
    															// unChaval ne peut pas utiliser la methode spécifique de Pegassus car c'est typé Horse
    - Même si la variable qui contient l’instance d’une classe fille est typée par la classe mère, 
    	lorsqu’une méthode est redéfinie, c’est le code de la classe fille qui est exécuté.			// polymorphisme à l’exécution
    - on y ajoute l’annotation @Overidde juste avant la signature pour informer qu’une méthode est redéfinie.
    - mot clé "final" :
        * final nomClass = ce classe n'est pas extendable 
        * final nomMethode = ce methode n'est pas redefinissable dans les classe enfants  
        * final nomVariable = ce classe n'est pas modifiable (constant)
     

    ex : Horse.java
        package jc.entities;
        public class Horse {
            protected String name;
            protected int posX;
            protected int posY;
            public Horse(String name) {
                this.name = name;
                this.posX = 50;
                this.posY = 50;
            }
            public void move(int x, int y) {
                this.posX = x;
                this.posY = y;
                System.out.println("Le Cheval se déplace (X = " + this.posX + ", Y = " + this.posY + ")");
            }
        }

    ex : Pegasus.java        
        package jc.entities;
        public class Pegasus extends Horse {
            protected int posZ;
            public Horse(String name) {
                super();
                this.posY = 50;
            }
            public void move(int x, int y) {
                this.posX = x;
                this.posY = y;
                System.out.println("La Pégase s'envole dans les airs (X = " + this.posX + ", Y = " + this.posY + ", Z = " + this.posZ +")");
            }
        }


CLASSE ABSTRAITE -------------------------------------------------------------------------------------------

    -  Une classe abstraite est une classe qui ne peut pas être instanciée directement. 
    -  Elle sert de modèle pour d'autres classes.
    
    Caractéristiques principales :
        * Peut contenir des méthodes abstraites (sans implémentation => qu'on ne définit pas dans la classe)        => au moins une
            et des méthodes concrètes (avec implémentation => qu'on définie dans la classe).
        * Peut avoir des variables d'instance (propriété), des constructeurs, et des méthodes avec un corps.
        * Une sous-classe doit hériter de la classe abstraite et implémenter toutes ses méthodes abstraites, 
            sauf si la sous-classe elle-même est déclarée abstraite.
        * peut étendre d'une autre classe abstraite

METHODE ABSTRAITE -------------------------------------------------------------------------------------------

    - Une méthode abstraite est une méthode qui n’a pas de corps (pas de code dans les accolades). 
    - Elle est uniquement définie pour être implémentée par des sous-classes.

Caractéristiques principales :
        * Elle est déclarée avec le mot-clé abstract.
        * Elle ne peut exister que dans une classe abstraite.
        * Elle force les classes dérivées à fournir une implémentation.


INTERFACE ---------------------------------------------------------------------------------------------------

    - Une interface en Java est un "contrat". Ce "contrat" stipule que toute classe qui implémente une 
        interface doit fournir des implémentations pour toutes les méthodes déclarées dans cette interface.
    - en terme d'explication, c'est comme si une interface c'est une classe abstraite dont toute les methodes
        sont toutes abstraites.

    - NB :
    	* elle peut avoir des variables qui sont automatiquement public, static et final, on dit que ce sont des constantes.
        * on n'a pas besoin de spécifié "public" et "abstract" car toutes est publique et abstrait par défaut,
            mais on peut aussi le faire.
        * on fait "interface" au lieu de "class"
        * peut étendre d'une autre interface (extends)
        * on emploie le mot clé "implements" si une classe veut implémenter une interface (Rq : les extends d'abord)
        * une classe peut implémenter plusieurs interface (implémentation multiple)
        * On ne peut pas forcer une classe abstraite de redefinir une methode de l'interface même s'il
        	l'implemente, par contre les classes fille doit redéfinir la methode. 
        * Une variable peut être typée par une interface.
    
    ex : Volant.java
    interface Volant {
        void voler();
    }

    ex : Oiseau.java
    public class Oiseau implements Volant {
        @Override
        public void voler() {
            System.out.println("L'oiseau vole.");
        }
    }

    ex : Avion.java
    public class Avion implements Volant {
        @Override
        public void voler() {
            System.out.println("L'avion vole.");
        }
    }
    
    NB: - Les interfaces fonctionnelles ont la particularité de définir une seule méthode abstraite  
			@FunctionnalInterface
			public interface IAffichage {
			    void afficher(String texte);
			}


EXPRESSION LAMBDA ---------------------------------------------------------------------------------------------

	Une expression lambda est une fonction anonyme car elle n’a pas besoin d’être définie dans le cadre 
	d’une classe. Grâce à cela, cette fonction est considérée comme une valeur qu’on peut affecter à une 
	variable ou passé en paramètre d’une autre fonction.
	Syntaxe:
		(paramètres) -> { corps de la fonction }
		✔️ Les paramètres sont passés entre ().
		✔️ La flèche -> sépare les paramètres et le corps de la fonction.
		✔️ Si le corps contient une seule instruction, {} sont optionnels.
		
	NB : 
		- un interface fonctionnelle est le type associé à une expression lambda
		
		- Il existe de nombreuses interfaces fonctionnelles (ou fonction anonyme) dans le langage Java, par exemple :
			Predicate : la méthode prend un paramètre générique de type T et renvoie un booléen.
			Function : la méthode prend un paramètre générique de type T et renvoie une valeur générique de type R.
			Consumer : la méthode prend un paramètre générique de type T et ne renvoie rien.
			Runnable : la méthode ne prend pas de paramètre et ne renvoie rien.
			
			// Callable : la méthode ne prend pas de paramètre et renvoie une valeur générique de type R
		
		ex : 
			Consumer<String> fn = (mot) -> System.out.print(mot);	// on peut affecter à une variable (ici c'est pas utile mais pour l'exemple)
			motCles.foreach(fn);									// foreach d'un objet Collection prend en paramètre un fonction "Consummer"

            --------------------------------------------------------------------------------------------------------------------------------
            Interface	    Rôle	                                            Méthode principale              Exemple d’utilisation
            --------------------------------------------------------------------------------------------------------------------------------
            Predicate<T>	Teste une condition et retourne true/false	        boolean test(T t)	            Filtrage d’une liste                    // fn.test("Jean")      => return true
            Function<T, R>	Transforme un objet T en R	                        R apply(T t)	                Convertir un mot en longueur            // fn.apply("Jean")     => return "Jeannette"
            Consumer<T>	    Effectue une action sur T sans retour	            void accept(T t)	            Afficher un message                     // fn.accept("Jean")    => return void
            Runnable	    Exécute une tâche sans paramètre ni retour	        void run()	                    Thread                                  // fn.run()             => return void
            --------------------------------------------------------------------------------------------------------------------------------

        exemples : Predicate<T>
            Predicate<Integer> estPair = n -> n % 2 == 0;
            System.out.println(estPair.test(4)); // true
            System.out.println(estPair.test(7)); // false
            List<Integer> nombres = Arrays.asList(1, 2, 3, 4, 5, 6);
            List<Integer> pairs = nombres.stream().filter(estPair).collect(Collectors.toList());
            System.out.println(pairs); // [2, 4, 6]

        exemples : Function<T,R>
            Function<String, Integer> longueurMot = mot -> mot.length();
            System.out.println(longueurMot.apply("Java"));   // 4
            System.out.println(longueurMot.apply("Lambda")); // 6

        exemples : Consumer<T>
            Consumer<String> afficher = nom -> System.out.println("Bonjour " + nom);
            afficher.accept("Alice"); // Bonjour Alice
            List<String> noms = Arrays.asList("Bob", "Charlie", "David");
            noms.forEach(afficher);

        exemples : Runnable
            Runnable tache = () -> System.out.println("Tâche exécutée !");
            Thread thread = new Thread(tache);
            thread.start();

LES RÉFÉRENCES À DES MÉTHODES (Method reference) --------------------------------------------------------------

    permettent de remplacer une expression lambda lorsqu'elle appelle directement une méthode existante. 
    Elles rendent le code plus lisible et concis.

    Une référence à une méthode utilise :: (double deux-points) et suit l'une des formes suivantes :
        ClassName::staticMethod      // Référence à une méthode statique
        objet::instanceMethod        // Référence à une méthode d'instance sur un objet existant
        ClassName::instanceMethod    // Référence à une méthode d'instance sur un objet arbitraire
        ClassName::new               // Référence à un constructeur

    Exemples : Remplace une lambda qui appelle une méthode statique
        Function<String, Integer> lambda1 = s -> Integer.parseInt(s);       // Lambda classique
        Function<String, Integer> refMethode = Integer::parseInt;           // Avec une référence de méthode

        System.out.println(refMethode.apply("123"));                        // 123

    Exemples : Utilisé lorsque la méthode appartient à une instance spécifique
        String message = "Bonjour";
        Supplier<Integer> lambda2 = () -> message.length();                 // Lambda classique
        Supplier<Integer> refMethode = message::length;                     // Avec une référence de méthode

        System.out.println(refMethode.get());                               // 7

    Exemples : Utilisé lorsqu’on travaille sur une collection d'objets
        List<String> noms = Arrays.asList("Alice", "Bob", "Charlie");
        noms.forEach(nom -> System.out.println(nom));                       // Lambda classique
        noms.forEach(System.out::println);                                  // Avec une référence de méthode

    Exemples : Utilisé pour créer un objet avec new
        Supplier<Voiture> lambda4 = () -> new Voiture();                    // Lambda classique
        Supplier<Voiture> refConstructeur = Voiture::new;                   // Avec une référence de constructeur

        refConstructeur.get();                                              // "Nouvelle voiture créée !"


POLYMORPHISME ---------------------------------------------------------------------------------------------



COLLECTION ---------------------------------------------------------------------------------------------

La collection est une interface qui est l'ensemble de tous ce qui est structure de données (pile, liste, file,...). 
Elles peut stocker une quantité variable des ELEMENTS (données) qui est gérer de façon dynamique au niveau de la mémoire.

Les classes qui implements l'interface collection auront ces methodes :
    * add(ELEMENT) : ajouter un élément
    * addAll(COLLECTION) : ajouter tous les elements d'une autre collection
    * clear() : supprimer tous les elements d'une collection 
    * remove(INDEX) : supprimer un element
    * contains(ELEMENT) : vérifier si elle contient un element
    * isEmpty() : vérifier si elle est vide
    * size() : vérifier le nombre d'element (length)
    * toArray() : transformer en Array classique
    * ... (voir la documentation)
    - Collections.sort(collections) => trie les elements de la collection (import java.util.Collections)
    - Collections.swap(collections, index, index) => échanger les positions de deux éléments dans une collection


Les classes qui implements l'interface collection :
    * ArrayList, LinkedList, Vector, HashSet, TreeSet, Stack, HashMap, TreeMap


Définition du fichier "ressources/tableau-specificite-des-classes-de-collections.png":
    ~ ordonnées : indique si les éléments de la collection conservent l'ordre dans lequel ils ont été ajoutés
    ~ doublons : précise si la collection autorise plusieurs occurrences du même élément (doublons)
    ~ accès direct : indique si les éléments de la collection peuvent être accédés rapidement par un index ou une clé. 
                    Si Non, nécessite une itération pour trouver un élément.
    ~ valeurs nulles : indique si la collection peut contenir des valeurs nulles (éléments ou clés nulles)
    ~ thread safe : Précise si la collection est sûre pour une utilisation concurrente (accès simultané par plusieurs 
                    threads sans provoquer d'erreurs ou de comportements inattendus).
                    ✅ : La collection est conçue pour être utilisée dans des environnements multithreads.
                    ❌ : La collection n'est pas thread-safe et nécessite une synchronisation explicite si 
                            utilisée avec plusieurs threads.
 
LISTE ---------------------------------------------------------------------------------------------


    Les classes qui implements l'interface LIST sont : (LIST étend de COLLECTION)

        * ArrayList : (MonoT, accès direct, optimisé pour la lecture)               // Tableau dynamique
        * LinkedList :  (MonoT, optimisé pour l'écriture)                           // liste chaîné (doublement chaîné)
        * Vector : (MultiT, accès direct, optimisé pour la lecture)                 // Obsolete pour java 21
        * Stack (étend Vector) : MultiT, LIFO(pile), extends Vector

    Ces 04 classes ont les spécificités de : 
        - permettent de travailler avec des elements ordonnées,
        - acceptent les doublons,
        - acceptent les valeurs nulles


    utilisation : 
        * ArrayList<nomClass> nomVariable = new ArrayList<nomClass>(10);        // nomClass => String, Integer, NomClasse,... (pas de type primitive)
                                                                                // 10 => capacity (on peut ne pas spécifié paske c'est dynamique)
                                                                                
        * Vector<nomClass> nomVariable = new Vector<nomClass>(10);              // pour la solution multithread

            --------------------------------------------------------------------------------------------------
                Aspect	            Array	                        ArrayList
            --------------------------------------------------------------------------------------------------
                Taille	            Fixe	                        Dynamique
                Type de données	    Primitifs et Objets	            Uniquement Objets
                Méthodes	        Pas de méthodes intégrées	    Méthodes pour ajouter, supprimer, etc.
                Performance	        Plus rapide pour des 	        Plus lent en raison de sa flexibilité
                                    opérations simples
                Framework 	        Pas directement compatible	    Compatible
                Collections
            --------------------------------------------------------------------------------------------------
            

            - nomVariable.add(cat) => ajouter l'instance cat de Cat dans nomVariable de type ArrayList<Cat>
            - nomVariable.add(25) => ajouter le nombre "25" dans nomVariable de type ArrayList<Integer>
            - nomVariable.get(2) => récupérer le 3è element de collection nomVariable (accès direct)


        * LinkedList<nomClass> nomVariable2 = new LinkedList<nomClass>();               // liste chaînée
            
            - nomVariable2.add(cat) => ajouter l'instance cat de Cat dans nomVariable2 de type LinkedList<Cat> à la fin
            - nomVariable2.addFirst(cat) => ajouter l'instance cat de Cat dans nomVariable2 de type LinkedList<Cat> au debut
            - nomVariable2.remove(cat) => enlever l'instance cat de Cat dans nomVariable2 de type LinkedList<Cat> à la fin
            - nomVariable2.removeFirst(cat) => enlever l'instance cat de Cat dans nomVariable2 de type LinkedList<Cat> au debut
            - nomVariable2.getFirst()
            ~ ListIterator : on doit itérer la linkedList parce que ses elements n'est pas accessible directement 
                ListIterator<nomClass> iter = nomCollection.listIterator();             // import java.util.ListIterator
                while (iter.hasNext()) {
                    iter.next().nomMethodeClasse();                                      // iter.next = element
                }


            Avantages
                Insertion et suppression rapides (surtout au début ou au milieu).
                Ordre conservé.
                Peut être utilisée comme une pile (Stack), une file ou une file double (Deque).
            Inconvénients
                Accès lent par index : Chaque accès nécessite de parcourir la liste depuis le début ou la fin.
                Consommation mémoire élevée : Chaque nœud utilise plus de mémoire (en raison des références au précédent et au suivant).
                Non thread-safe : Nécessite une synchronisation manuelle si utilisée par plusieurs threads.

                --------------------------------------------------------------------------------------------------
                    Aspect	            LinkedList	                    ArrayList
                --------------------------------------------------------------------------------------------------
                    Taille dynamique	Oui	                            Oui
                    Accès par index	    Lent (parcours des nœuds)	    Rapide (tableau sous-jacent)
                    Ajout/Suppression	Rapide pour début/milieu	    Rapide pour la fin
                    Structure interne	Doublement chaînée	            Basée sur un tableau
                    Mémoire	            Plus gourmand 	                Moins gourmand
                                        (stocke des références)
                --------------------------------------------------------------------------------------------------


        * Stack<nomClass> nomVariable3 = new Stack<nomClass>();               // pile (LIFO), import java.util.ListIterator
        
            - nomVariable3.push(cat) => ajouter l'instance cat de Cat dans la collection nomVariable3
            - nomVariable3.pop() => supprimer le dernier instance dans la collection nomVariable3 
            - nomVariable3.peek() => récupérer le dernier instance dans la collection nomVariable3

            
FILE (Queue) - FIFO (First in, First out) -----------------------------------------------------------

    L’interface "Queue" représente une file d'attente (FIFO : First In, First Out).c'est une enfant de 
    Collection dans ressources/interface-enfant-de-collection.png: (file d'attente)
    
    Les deux principales sous-interfaces :

        - PriorityQueue
            Une PriorityQueue est une file où les éléments ne sont pas nécessairement traités selon leur ordre d'insertion, 
            mais selon leur priorité définie par un ordre naturel (Comparable) ou un comparateur (Comparator).

            * Caractéristiques :
                ~ ✅ Ordonnée : Ordre basé sur la priorité des éléments.
                ~ ✅ Doublons
                ~ ❌ accès direct.
                ~ ❌ non thread-safe.
                ~ ❌ valeurs null.

            * PriorityQueue<nomClass> queue = new PriorityQueue<>();        // nomClass n'a pas besoin d'implementer l'interface comparable 
                                                                                parce qu'il est ordonnée par l'ordre d'insertion
            * queue.offer(element) => ajout d'élément
            * queue.poll(element) => récupérer ensuite supprimer le 1er élément selon l'ordre de priorité

        
        - Deque (Double-Ended Queue = Tableau doublement chaînée)
            L’interface "Deque" est une file d'attente qui permet d'ajouter et de retirer des éléments à 
            la fois au début et à la fin. Elle est plus flexible que Queue et peut être utilisée comme une 
            pile (LIFO) ou une file classique (FIFO).

            * Caractéristiques :
                ~ ✅ Ordonnée : Ordre d'insertion.
                ~ ✅ Doublons
                ~ ❌ accès direct.
                ~ ❌ non thread-safe.
                ~ ❌ valeurs null.
                ✅ Permet l'ajout/suppression des deux côtés.
                ✅ Implémentée par LinkedList ou ArrayDeque(plus rapide).
                ✅ ArrayDeque est plus rapide que Stack et ne permet pas null.

            * ArrayDeque :
                ArrayDeque<nomClass> adeque = new ArrayDeque<>();            // nomClass doit implementer l'interface comparable 
                                                                            // les Integer, String,... implémentent déjà comparable
                ~ adeque.addFirst(element) / addLast(element)
                ~ adeque.removeFirst() / removeLast()
                ~ adeque.getFirst() / getLast()
                ~ adeque.offertFirst(element) / offertLast(element)
                ~ adeque.pollFirst() / pollLast()
                ~ adeque.peekFirst() / peekLast()
                ~ adeque.removeFirstOccurrence(4) : supprimer le 1er valeur "4" du collection "adeque"
                ~ adeque.removeLastOccurrence(5) : supprimer le dernier valeur "4" du collection "adeque"



ENSEMBLE (SET) ------------------------------------------------------------------

    L'interface Set<E> (du package java.util) est une collection qui ne permet pas les doublons. 
    Elle est principalement utilisée lorsque vous devez stocker des éléments uniques et que l'ordre 
    des éléments n'est pas votre priorité.
    
    * Caractéristiques :
        ❌ Doublons.
        ❌ non thread-safe.

    1. HashSet – Unicité sans ordre
        Un HashSet est basé sur une table de hachage, garantissant que chaque élément est unique 
        grâce à la méthode hashCode().

        Caractéristiques :
            ❌ ordonnées.
            ❌ Non thread-safe
            ✅ accès direct.
            ✅ Autorise un élément null, mais pas plusieurs.
            ✅ Très performant pour les recherches, ajouts et suppressions (O(1) en moyenne).

        Syntaxe : 
            HashSet<String> set = new HashSet<>();

    
    2. LinkedHashSet – Unicité avec ordre d’insertion
        C’est une variante de HashSet qui préserve l’ordre d’insertion des éléments.

        Caractéristiques :
            ✅ ordonnée : l’ordre d’insertion.
            ✅ Un peu plus lent que HashSet, car il utilise une liste doublement chaînée pour suivre l’ordre.
            ✅ Permet un null unique.
            
        Syntaxe : 
            HashSet<String> set = new HashSet<>();


    3. TreeSet – Unicité avec tri automatique (arbre binaire)
        Un TreeSet est basé sur un arbre binaire équilibré (Red-Black Tree), ce qui permet 
        de stocker les éléments triés.

        Caractéristiques :
            ✅ ordonnée : l’ordre naturel (Comparable) ou un Comparator personnalisé.
            ❌ Non thread-safe
            ❌ accès direct.
            ❌ valeurs null.
            ❌ Plus lent que HashSet pour l’insertion et la recherche (O(log N) au lieu de O(1)).
            
        Syntaxe : 
            TreeSet<Integer> TSet = new TreeSet<>();

            ~ TSet.first(element) / last(element) : récupérer
            ~ TSet.headSet(element) : récupérer un sous ensemble de la collection depuis le debut jusqu'à "element" (element exclus)
            ~ TSet.tailSet(element) : récupérer un sous ensemble de la collection depuis "element" jusqu'à la fin (element inclus)
            ~ TSet.subSet(elem1, elem2) : récupérer un sous ensemble de la collection depuis "elem1" jusqu'à la "elem2" (elem1 inclus, elem2 exclus)



    NB : - tous les Classes d'elements qui vont s'ajouter dans la collection "SET" vont devoir ré-implementer
            les methodes "hashCode()" et "equals()" pour que les interface "SET" recherche les doublons. (sauf Integer, String,...)
         - les elements de "TreeSet" devoir ré-implementer les comparators.




CARTE (MAP) (key : value) ------------------------------------------------------------------

    L'interface Map<K, V> (du package java.util) représente une collection clé-valeur, où :
        - Chaque clé est unique (pas de doublons de clé).
        - Chaque valeur est associée à une clé.
        - L'accès aux valeurs se fait via les clés.
    
    * Caractéristiques :
        ✅ accès direct.
        ❌ Doublons (key).
        ❌ non thread-safe.

    1. HashMap – Rapide mais sans ordre
        Une HashMap est basée sur une table de hachage et permet un accès très rapide aux valeurs via 
        leurs clés.

        Caractéristiques :
            ❌ ordonnée
            ✅ une seule clé null et plusieurs valeurs null.
            ✅ Excellente performance pour la recherche, l’ajout et la suppression (O(1) en moyenne).

        Syntaxe : 
            HashMap<String, String> HMap = new HashMap<>();

            ~ HMap.put(key, value) : ajouter un element
            ~ HMap.get(key) : récupérer un la valeur de l'element qui a la clé "key"
            ~ HMap.containsKey(key) / contains(value)
            ~ for( String k : HMap.keySet()) : parcours HMap
                * keySet() => ensemble des clés
                * values() => ensemble des valeurs
            ~ for( Map.Entry<String, String> entry : HMap.entrySet()) => ensemble des clés-valeurs (des entrées, des enregistrements)
                * entry.getKey()
                * entry.getValue()


    2. LinkedHashMap – Ordre d’insertion préservé
        Un LinkedHashMap est une version améliorée de HashMap qui conserve l’ordre d’insertion des éléments.

        Caractéristiques :
            ✅ Conserve l’ordre d’insertion.
            ✅ Permet une seule clé null et plusieurs valeurs null.
            ❌ Légèrement plus lent que HashMap, car il maintient une liste chaînée pour l’ordre.

        Syntaxe : 
            LinkedHashMap<Integer, String> LHmap = new LinkedHashMap<>();


    3. TreeMap – Tri automatique des clés
        Un TreeMap est basé sur un arbre binaire équilibré (Red-Black Tree) et trie automatiquement les clés.

        Caractéristiques :
            ✅ Ordonnée : ordre naturel (Comparable) ou un Comparator.
            ✅ Ne permet pas de clé null, mais permet des valeurs null.
            ❌ Plus lent que HashMap pour l’ajout et la suppression (O(log N) au lieu de O(1)).

        Syntaxe : 
            TreeMap<Integer, String> Tmap = new TreeMap<>();

            ~ Tmap.put(element) / last(element) : ajout / récupérer
            ~ TreeMap<Integer, String> map = new TreeMap<>((a, b) -> b - a);        // Trier (alphabet décroissant)

    -----------------------------------------------------------------------------------------------------------------
    Critère	            HashMap	              LinkedHashMap	            TreeMap	            Hashtable
    -----------------------------------------------------------------------------------------------------------------
    Ordre des           ❌ Non garanti	    ✅ Ordre d’insertion	    🔢 Trié par clé	    ❌ Non garanti
    éléments	
    Performance	        🚀 O(1)	             🐢 O(1) (plus lent)	  🐌 O(log N)	      🐢 O(1) (moins efficace)
    (Ajout/Suppression)
    Recherche	        O(1)	              O(1)	                    O(log N)	        O(1)
    Clé null autorisée	✅ Oui (une seule)	✅ Oui (une seule)	    ❌ Non	            ❌ Non
    Valeur null 	    ✅ Oui	            ✅ Oui	                ✅ Oui	            ❌ Non
    autorisée
    Thread-safe ?	    ❌ Non	            ❌ Non	                ❌ Non	            ✅ Oui
    -----------------------------------------------------------------------------------------------------------------
    
    Quand utiliser quel Map ?
        ✔ Utilisez HashMap si vous voulez les meilleures performances sans vous soucier de l’ordre.
        ✔ Utilisez LinkedHashMap si vous voulez conserver l’ordre d’insertion.
        ✔ Utilisez TreeMap si vous avez besoin d’un tri automatique des clés.
        ✔ Évitez Hashtable, utilisez plutôt ConcurrentHashMap si vous avez besoin d’une Map



ENUMERATION (ENUM) -------------------------------------------------------------------------

    En Java, une énumération (ou "enum") est un type de classe spécial qui permet de définir un 
    ensemble fixe de constantes nommées.
        public enum Jour {
            LUNDI, MARDI, MERCREDI, JEUDI, VENDREDI, SAMEDI, DIMANCHE
        }

        Jour jour = Jour.LUNDI;
        System.out.println(jour);       // LUNDI


    * Associer des valeurs avec les "enum"
        public enum Statut {
            ACTIF(1), INACTIF(0), SUSPENDU(-1);

            private int code; // Attribut

            Statut(int code) { // Constructeur, on met le parametre meme si on l'appelle pas
                this.code = code;
            }

            public int getCode() { // Getter
                return code;
            }
        }

        Statut s = Statut.ACTIF;
        System.out.println(s.getCode()); // 1


    * Ajouter des méthodes (ex : Trouver un enum à partir d’un code)

        public enum Statut {
            ACTIF(1), INACTIF(0), SUSPENDU(-1);

            private int code;

            Statut(int code) {		// on met le parametre meme si on l'appelle pas
                this.code = code;
            }

            public int getCode() {
                return code;
            }

            public static Statut fromCode(int code) {
                for (Statut s : Statut.values()) {
                    if (s.getCode() == code) {
                        return s;
                    }
                }
                throw new IllegalArgumentException("Code inconnu : " + code);
            }
        }

        Statut s = Statut.fromCode(1);
        System.out.println(s); // ACTIF


    * Différence entre enum et final static
        Avant les enum, on utilisait souvent final static pour représenter des constantes :

            public class Statut {
                public static final int ACTIF = 1;
                public static final int INACTIF = 0;
                public static final int SUSPENDU = -1;
            }

        📌 Pourquoi enum est mieux ?
            ✔ Sécurité → Impossible de mettre une valeur inconnue (ex: Statut.ACTIF est sûr).
            ✔ Lisibilité → Pas besoin de se souvenir des valeurs (1, 0, -1 sont abstraits).
            ✔ Fonctionnalités → Peut contenir des méthodes et être utilisé avec switch.
            ✔ comparaison → avec simplemnt "=="

    
    ~ Statut.valueOf(element) : recuperer la valeur d'éléments de l'enum "Statut"
    ~ element.name() : recuperer le nom d'éléments d'une enum
    ~ element.ordinal() : recuperer le rang de l'enum (comme index)
    ~ for (Statut s : Statut.values()) : parcours (values => obtenir tous les éléments d'une enum)
    

NB : 
    - on ne peut pas étendre d'une Classe ni étendre une Enum (parce que c'est une classe final par défaut)
    - tout les attributs sont privé par défaut si on ne met pas de porté (la liste des valeurs d'une enum ne sont pas des attribus)
    - on ne peut pas créer un instance d'un Enum (parce que le constructeur est privé)
    - pour créer une enum associé des valeurs, on doit lui fournir un constructeur.
    - comme pour tous les classes, les methodes et les attributs est "private" par défaut si on ne met pas "public" 
      dans sa signature. (mais la propriété reste privé même si on lui met "public")
    - on peut mettre un enum dans une classe
	    public class GameController {
			enum GameState {
				AddPlayer, CardDealt, WinnerRevealed
			}




GENERICITE <T> --------------------------------------------------------------------------

    La généricité en Java est une fonctionnalité qui permet de créer des classes, des interfaces et des 
    méthodes qui peuvent être utilisées avec différents types de données sans avoir à les spécifier 
    explicitement à chaque fois :

            public class Boite<T> {
                private T contenu;

                public Boite(T contenu) {
                    this.contenu = contenu;
                }

                public T getContenu() {
                    return contenu;
                }

                public void setContenu(T contenu) {
                    this.contenu = contenu;
                }
            }

            Boite<Integer> boiteEntier = new Boite<>(10);
            Boite<String> boiteChaine = new Boite<>("Bonjour");


        ~ public class Boite<T extends Number> : accepte tous les Objet qui étend la classe "Number"    (Box<Double> doubleBox = new Box<>(5.5))
        ~ class KeyValue<K, V> implements Pair<K, V> : implement l'interface Pair<K, V>                 ( Pair<Integer, String> p = new KeyValue<>(1, "One"); )
        ~ public static void printNumbers(List<? extends Number> numbers)
                List<Integer> intList = List.of(1, 2, 3);
                printNumbers(intList); // ✅ OK, Integer est un Number
        ~ public static void addInteger(List<? super Integer> list)
                List<Number> numList = new ArrayList<>();
                addInteger(numList); // ✅ OK, Number est une superclasse de Integer

    NB :
        En Java, on ne peut pas créer directement un tableau de type générique.
        Solution : Utiliser Array.newInstance()
            class Box<T> {
                private T[] array;

                @SuppressWarnings("unchecked")
                public Box(Class<T> clazz, int size) {
                    array = (T[]) java.lang.reflect.Array.newInstance(clazz, size);
                }
            }
        
        Box<String> stringBox = new Box<>(String.class, 10);

    -----------------------------------------------------------------------------------------------------
        Critère	            List<?> (Wildcard générique)	    List<T> (Type paramétré)
    -----------------------------------------------------------------------------------------------------
        Flexibilité	        Accepte toutes les listes 	        Type unique défini (List<T>, 
                            (List<Integer>, List<String>...)    ex: List<Integer>)
        Lecture (get())	    ✅ Possible	                      ✅ Possible
        Ajout (add())	    🚫 Impossible (sauf null)	       ✅ Possible (ajout d'éléments du type T)
        Utilisation de T	❌ Pas de T, seulement Object	  ✅ Utilisation directe de T
    -----------------------------------------------------------------------------------------------------
     Quand utiliser quoi ?
        ------------------------------------------------------------------------------------
            Cas d'usage	                                     Quelle version choisir ?
        ------------------------------------------------------------------------------------
            Lecture seule, sans modifier la liste	        List<?> (car plus flexible)
            Lecture + Ajout d’éléments du même type	        List<T> (car permet les ajouts)
            Méthode acceptant plusieurs types (Integer,	    List<?>
            String, etc.)
        ------------------------------------------------------------------------------------
    📌 Exemple pratique :
        List<?> : Idéal pour une méthode d'affichage qui ne doit pas modifier la liste.
        List<T> : Idéal pour une méthode qui manipule les éléments (ajout, suppression, transformation...).



    - Avantages de la généricité :
        Sécurité du type: La généricité permet de s'assurer que les données manipulées sont du bon type au 
                            moment de la compilation, ce qui évite les erreurs de type à l'exécution.
        Réutilisabilité du code: La généricité permet de créer des classes et des méthodes qui peuvent être 
                            utilisées avec différents types de données, ce qui réduit la quantité de code à écrire et à maintenir.
        Lisibilité du code: La généricité rend le code plus lisible en indiquant clairement le type de données
                            manipulées.



DATE ET DURÉES --------------------------------------------------------------------------------

    1️⃣ LocalDate – Manipulation de la date uniquement
        Utilisé quand seule la date est importante (sans heure).

        Ex :
            import java.time.LocalDate;
            public class Main {
                public static void main(String[] args) {
                    // Date actuelle
                    LocalDate today = LocalDate.now();
                    System.out.println("Aujourd'hui : " + today);               // 2025-02-05 (Année - Mois - Jour)

                    // Date spécifique (année, mois, jour)
                    LocalDate date = LocalDate.of(2025, 2, 5);      
                    System.out.println("Date spécifique : " + date);            // 2025-02-05

                    // Ajouter/Soustraire des jours/mois/années
                    LocalDate futureDate = today.plusDays(10);
                    LocalDate pastDate = today.minusMonths(2);
                    System.out.println("Dans 10 jours : " + futureDate);        // 2025-02-15
                    System.out.println("Il y a 2 mois : " + pastDate);          // 2024-12-05

                    // Comparaison de dates
                    boolean isBefore = date.isBefore(today);
                    boolean isAfter = date.isAfter(today);
                    System.out.println("Est avant aujourd'hui ? " + isBefore);  // false
                    System.out.println("Est après aujourd'hui ? " + isAfter);   // false
                }
            }

            instanciation :
                ~ LocalDate.EPOCH() : créer une date "1970-01-01"
                ~ LocalDate.now() : créer une date d'aujourd'hui
                ~ LocalDate.of(1988, 03, 14) : créer une date spécifique (année - mois - jour)
            methodes :
                ~ myDate.getYear() : récupérer l'année
                ~ myDate.getMonthValue() : récupérer le mois numérique (ex: 03)
                ~ myDate.getMonth() : récupérer le mois literal (ex: MARCH)
                ~ myDate.getDayOfMonth() : récupérer le mois numérique (ex: 22)
                ~ myDate.getDayOfWeek() : récupérer le mois literal (ex: Saturday)
                ~ myDate.plusYears(4) / plusMonths(15) / plusDays(35) : ajout d'année/mois/jours
                ~ myDate.minusYears(4) / minusMonths(15) / minusDays(35) : soustraction d'année/mois/jours
                ~ myDate.plus(Period)



    2️⃣ LocalTime – Manipulation de l'heure uniquement
        Utilisé quand seule l’heure est importante (sans date).

        Ex :
            import java.time.LocalTime;
            public class Main {
                public static void main(String[] args) {
                    // Heure actuelle
                    LocalTime now = LocalTime.now();
                    System.out.println("Heure actuelle : " + now);              // 14:45:10.123

                    // Heure spécifique (heures, minutes, secondes)
                    LocalTime time = LocalTime.of(14, 30, 15);
                    System.out.println("Heure spécifique : " + time);           // 14:30:15

                    // Ajouter/Soustraire des heures/minutes/secondes
                    LocalTime futureTime = now.plusHours(3);
                    LocalTime pastTime = now.minusMinutes(20);
                    System.out.println("Dans 3 heures : " + futureTime);        // 17:45:10.123
                    System.out.println("Il y a 20 minutes : " + pastTime);      // 14:25:10.123

                    // Comparaison d'heures
                    boolean isBefore = time.isBefore(now);
                    boolean isAfter = time.isAfter(now);
                    System.out.println("Est avant maintenant ? " + isBefore);   // true
                    System.out.println("Est après maintenant ? " + isAfter);    // false
                }
            }

            instanciation :
                ~ LocalTime.now() : créer un temps d'aujourd'hui
                ~ LocalTime.of(19, 03, 14) : créer un temps spécifique (heure - minute - sec)
            methodes :
                ~ myTime.getHour() : récupérer l'heure
                ~ myTime.getMinute() : récupérer le minute
                ~ myTime.plusHours(4) / plusMinutes(15) / plusSecondes(35) : ajout 
                ~ myTime.minusHours(4) / minusMinutes(15) / minusSecondes(35) : soustraction 
                ~ myTime.plus(Duration) : ajout d'une durée 


    3️⃣ LocalDateTime – Combinaison de date et heure
        Utilisé quand date + heure sont importantes ensemble.

        Ex :
            import java.time.LocalDateTime;
            public class Main {
                public static void main(String[] args) {
                    // Date et heure actuelles
                    LocalDateTime now = LocalDateTime.now();
                    System.out.println("Date et heure actuelles : " + now);                 // 2025-02-05T14:45:10.123

                    // Date et heure spécifiques
                    LocalDateTime dateTime = LocalDateTime.of(2025, 2, 5, 14, 30, 15);
                    System.out.println("Date et heure spécifiques : " + dateTime);          // 2025-02-05T14:30:15

                    // Ajouter/Soustraire du temps
                    LocalDateTime futureDateTime = now.plusDays(5).plusHours(2);
                    LocalDateTime pastDateTime = now.minusMonths(1).minusMinutes(30);
                    System.out.println("Dans 5 jours et 2 heures : " + futureDateTime);     // 2025-02-10T16:45:10.123
                    System.out.println("Il y a 1 mois et 30 minutes : " + pastDateTime);    // 2025-01-05T14:15:10.123
                }
            }

            instanciation :
                ~ LocalDateTime.now() 
                ~ LocalDateTime.of(someDate, someTime) : créer un temps spécifique (Annee - Mois - Jour - heure - minute - sec)
            methodes : tout les methodes de LocalDate et LocalTime

    5️⃣ Durées et Périodes (Duration et Period)
        Period → Durée (jours, mois, années)

            Ex :
                import java.time.LocalDate;
                import java.time.Period;
                public class Main {
                    public static void main(String[] args) {
                        LocalDate startDate = LocalDate.of(2024, 1, 1);
                        LocalDate endDate = LocalDate.of(2025, 2, 5);

                        Period period = Period.between(startDate, endDate);

                        System.out.println("Différence : " + period.getYears() + " ans, " + 
                            period.getMonths() + " mois, " + period.getDays() + " jours");
                    }
                }

            methodes :
                ~ Period.of(03, 04, 06) : créer un Durée de 3ans, 4mois et 6j
                ~ Period.between(startDate, endDate) : créer une durée entre startDate et endDate


        Duration → Durée (heures, minutes, secondes)

            Ex :
                import java.time.Duration;
                import java.time.LocalTime;
                public class Main {
                    public static void main(String[] args) {
                        LocalTime startTime = LocalTime.of(10, 30);
                        LocalTime endTime = LocalTime.of(14, 45);

                        Duration duration = Duration.between(startTime, endTime);

                        System.out.println("Durée : " + duration.toHours() + " heures, " + 
                            duration.toMinutes() % 60 + " minutes");
                    }
                }

            methodes :
                ~ Duration.ofHours(3).plusMinutes(30) : créer une durée de 03h30    // affiche PT03H30
                ~ Duration.between(startTime, endTime) : créer une durée entre startTime et endTime


    6️⃣ Timezones avec ZoneId et ZonedDateTime

        📌 ZoneId – Représente un fuseau horaire
            ZoneId permet de définir un fuseau horaire spécifique (ex : "Europe/Paris", "GMT+3").

                import java.time.ZoneId;
                public class Main {
                    public static void main(String[] args) {
                        // Afficher le fuseau horaire par défaut
                        ZoneId defaultZone = ZoneId.systemDefault();
                        System.out.println("Fuseau par défaut : " + defaultZone);

                        // Définir un fuseau horaire spécifique
                        ZoneId parisZone = ZoneId.of("Europe/Paris");
                        System.out.println("Fuseau horaire de Paris : " + parisZone);
                    }
                }

        📌 ZonedDateTime – Manipuler une date/heure avec un fuseau horaire
            ZonedDateTime associe une date, une heure et un fuseau horaire.

                import java.time.ZonedDateTime;
                import java.time.ZoneId;
                public class Main {
                    public static void main(String[] args) {
                        // Date et heure actuelles avec fuseau par défaut
                        ZonedDateTime now = ZonedDateTime.now();
                        System.out.println("Date et heure actuelles : " + now);                 // 2025-02-06T14:45:10.123+01:00[Europe/Paris]

                        // Date et heure actuelles avec un fuseau horaire spécifique
                        ZonedDateTime parisTime = ZonedDateTime.now(ZoneId.of("Europe/Paris"));
                        System.out.println("Heure de Paris : " + parisTime);                    // 2025-02-06T14:45:10.123+01:00[Europe/Paris]

                        // Convertir une LocalDateTime en ZonedDateTime
                        ZonedDateTime newYorkTime = parisTime.withZoneSameInstant(ZoneId.of("America/New_York"));
                        System.out.println("Heure de New York : " + newYorkTime);               // 2025-02-06T08:45:10.123-05:00[America/New_York]
                    }
                }


    7️⃣ Formatage des Dates (DateTimeFormatter)
                import java.time.LocalDateTime;
                import java.time.format.DateTimeFormatter;
                public class Main {
                    public static void main(String[] args) {
                        LocalDateTime now = LocalDateTime.now();

                        // Définir un format personnalisé
                        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");

                        // Formater la date
                        String formattedDate = now.format(formatter);
                        System.out.println("Date formatée : " + formattedDate);
                    }
                }

            -------------------------------------------------------
                Motif	Exemple	    Description
            -------------------------------------------------------
                yyyy	2025	    Année sur 4 chiffres
                yy	    25	        Année sur 2 chiffres
                MM	    02	        Mois sur 2 chiffres
                MMM	    Fév	        Mois abrégé
                MMMM	Février	    Mois en toutes lettres
                dd	    06	        Jour sur 2 chiffres
                HH	    14	        Heure (24h)
                hh	    02	        Heure (12h)
                mm	    45	        Minutes
                ss	    10	        Secondes
            -------------------------------------------------------



THREADS ---------------------------------------------------------------------------------------------------

    Java prend en charge le multithreading, permettant d'exécuter plusieurs tâches en parallèle pour 
    améliorer les performances des applications.

    Un thread est un sous-processus léger qui peut s'exécuter indépendamment. Par défaut, un programme 
    Java s'exécute sur un thread principal appelé main thread.
        import java.lang.Thread; 
        System.out.println("Thread principal : " + Thread.currentThread().getName());           // main

    Il existe trois façons principales de créer un thread :

        1️⃣ En étendant Thread : On crée une classe qui hérite de Thread et on redéfinit la méthode run().
            (Ne pas appeler run() directement, sinon il s’exécutera comme une méthode normale)

            class MonThread extends Thread {
                public void run() {
                    System.out.println("Exécution du thread : " + Thread.currentThread().getName());
                }
            }

            MonThread thread1 = new MonThread();
            thread1.start();  // Démarrer le thread > Thread-0
            

        2️⃣ En implémentant Runnable (Best Practice ✅)
            class MonRunnable implements Runnable {
                public void run() {
                    System.out.println("Thread en cours d'exécution : " + Thread.currentThread().getName());
                }
            }

            Thread thread2 = new Thread(new MonRunnable());
            thread2.start();

            ~ Thread.sleep(1000) => faire un pause de 1000ms


        3️⃣ Les "Executors" pour être plus moderne (Écrivez un code concurrent)	// java.util.concurrent
            - newSingleThreadExecutor(): la possibilité d'avoir un thread
            - newCachedThreadPool(): la possibilité d'avoir un thread dynamique
            - newFixedThreadPool(): la possibilité d'avoir un nombre fixe de thread (pour les traitement plus lent)


            ~ ExecutorService ex = Executors.newSingleThreadExecutor();
            ~ ExecutorService ex = Executors.newCachedThreadPool();
            ~ ExecutorService ex = Executors.newFixedThreadPool(4);             // 4 = nbr de threads 

				// Callable : un methode qui ne prend pas de paramètre mais return un T	(java.util.concurrent.Callable)
                Runnable task = () -> {                 // expression lambda, Runneble ne renvoie rien	
                    ...
                }

                ex.execute(task);                       // executer task dans le "newSingleThreadExecutor"
                ex.shutdown();                          // Ferme l'executor après exécution

            avec ExecutorService on peut:
                * fermer l'executor après exécution avec shutdown()
                * avoir les resultats d'execution dans un variable de Type "Future" (java.util.concurrent)
                    Future<?> fut = executor.submit(task)       // <?> : générique (on ne sait pas quel type il récupère)
                    ~ fut.isDone() => est fini (boolean)
                    ~ fut.isCanceled() => est annulé (boolean)
                    ~ fut.get() => recupére les resultats
                    ~ fut.cancel() => annuler
                    
            Exemple concret: Construction de 10 blocs
        
			    Set<IBloc> blocs = new LinkedHashSet<IBloc>();
			    ExecutorService executorService = Executors.newFixedThreadPool(10);
			    
			    Callable<IBloc> taskMur1 = () -> { return new Mur(3, 2, 2, true); };
			    Callable<IBloc> taskMur2 = () -> { return new Mur(2, 1, 2, false); };
			    Callable<IBloc> taskPorte = () -> { return new Porte(1, 2, 2, true); };
			    Callable<IBloc> taskToit = () -> { return new Toit(3, 1, 1); };
			    
			    List<Callable<IBloc>> tasks = Arrays.asList(taskMur1, taskMur1, taskMur2, taskMur2, taskPorte, 
			    											taskToit, taskToit, taskToit, taskToit, taskToit);
			    try {
			        List<Future<IBloc>> resultas = executorService.invokeAll(tasks);
			        resultas.forEach((resultat) -> {
			        try {
			            blocs.add(resultat.get());
			        } catch (InterruptedException | ExecutionException e) {
			            logger.error("Erreur lors de création parallèle des blocs.");
			        }
			        });
			    } catch (InterruptedException e) {
			        logger.error("Erreur lors de création parallèle des blocs.");
			    }
			    executorService.shutdown();
			    
			    // si une crétion prend 1s : au lieu d’environ 10 secondes, le code met environ 1 seconde à s’exécuter
			    
		NB: Depuis la version 19 de Java, pour affronter les problèmes de concurrence, les Virtual Thread sont à votre disposition.
			(celle en dessus, on va l'appeler Platform Thread)
			(il faut juste cahnger newFixedThreadPool() par newVirtualThreadPerTaskExecutor() et on import dans l'exemple précédent)
			
			----------------------------------------------------------------------------------------------
								Gestionnaire du Thread			Conséquence
			----------------------------------------------------------------------------------------------
			Platform Thread		Système d’exploitation			Sollicite directement l’OS donc plus lourd
			Virtual Thread		JVM								Ne sollicite pas l’OS et donc plus léger.		// rapide à l'ecriture
			----------------------------------------------------------------------------------------------


DASE DE DONNEES ---------------------------------------------------------------------------------------------------

    JDBC est l'API standard de Java pour interagir avec une base de données relationnelle (comme MySQL, 
    PostgreSQL, Oracle, etc.). Elle permet aux applications Java d’exécuter des requêtes SQL et de manipuler 
    les données.


    Pour interagir avec une base de données via JDBC, il faut suivre ces 5 étapes :
        - Charger le Driver JDBC : mettre un pilote dans le classpath pour permettre à Java de communiquer 
                                    avec une base de données (en général .jar )
            et mettre :
                Class.forName("org.sqlite.JDBC")        // si c'est une base SQLite
        - Établir une Connexion : On utilise "DriverManager" pour établir une connexion avec la base de données (dans java.sql)
            Connection co = DriverMananager.getConnection()
            * SQLite => getConnection("jdbc:sqlite:path\\to\\db.sql");
            * MySQL => getConnection("jdbc:mysql://localhost:3306/dbname?useSSL=false", "user", "pass");
        - Exécuter des Requêtes SQL : On utilise "Statement" pour exécuter des requêtes SQL et "ResultSet" 
        pour stoquer les resultats de la requête.
            => Statement stmt = conn.createStatement();
            => ResultSet rs = stmt.executeQuery("SELECT * FROM products");
            s'il n'y a pas de resultat à recuperer (DELETE, UPDATE,...)
            => stmt.executeUpdate(...)      
        - Utiliser PreparedStatement : pour plus de Sécurisé (par ex, s'il y de données des utilisateur ou exterieur à entrer) ✅
            PreparedStatement stmt = conn.prepareStatement("UPDATE products SET product_name = ? WHERE product_id = ?");    // ? = Joker
            stmt.setString(1, "Jores");             // 1 = 1er joker
            stmt.setInt(2, 23);                     // 2 = 2e joker
            stmt.executeUpdate();                   // s'il n'y a pas de resulatat a recuperer sinon on fait un ResultSet avec executeQuery()
        - Fermer la Connexion 

NB : 
     - SQLite est un base de données portable, embarquée directement dans le projet sans connection à distant
     - Il faut Configurer le classpath:
        Ouvrez le fichier ".vscode/settings.json" de votre projet et ajoutez le chemin vers le fichier JAR. 
        Inserer cet code de configuration :
        {
            "java.project.referencedLibraries": [
                "lib/**/*.jar",
                ou
                "path/to/your/sqlite-jdbc-version.jar"
            ]
        }
     - certains drivers JDBC peuvent se charger automatiquement et s'enregistrer sans avoir besoin de 
        l'appeler explicitement dans Class.forName()
     - faire un "while (rs.next())" pour boucler sur tout les resultats trouver sur la réquête ("SELECT * FROM products")
        sinon il va faire les actions (par exemple : getString()) sur le prémier resultat trouver (comme first)


        ~ rs.getString("product_name) => Récuperer le champ "product_name" de la table "products" (getInt, getDouble,...)
        ~ 



JURNALISATION (LOGGING) --------------------------------------------------------------------------------------------

	La journalisation (logging) est une technique essentielle en Java pour enregistrer des messages sur l’état d’une 
	application, détecter des erreurs, surveiller son exécution, et faciliter le débogage.
	Au lieu d’utiliser System.out.println(), qui n’est pas flexible ni performant, Java propose des bibliothèques 
	spécialisées comme :
		* java.util.logging (JUL) (API intégrée à Java)
		* Log4j (Apache Log4j)
		* SLF4J (Simple Logging Facade for Java)
		* Logback (recommandé avec Spring Boot)
	
	Pourquoi utiliser un Logger
		✅ Différents niveaux de log (INFO, DEBUG, ERROR, etc.)
		✅ Possibilité de rediriger les logs vers des fichiers, la console, une base de données, etc.
		✅ Améliore la maintenabilité et le débogage
	
	Le concept consiste en l’association d’une trace avec un niveau. Ensuite lors de l’exécution de l’application le niveau 
	de log à utiliser est défini. Toutes les traces associées à ce niveau et au niveau supérieur sont utilisées.
		
	Voici un exemple de niveaux de log :
		Le niveau OFF sera donc celui à appliquer pour les utilisateurs finaux où nous ne voulons voir aucune trace.
		Le niveau ALL est son extrême opposé, il est le plus verbeux et affiche la moindre trace disponible ! 

		---------------------------------
		Nom du niveau	Valeur du niveau
		---------------------------------
		OFF				0
		FATAL			100
		ERROR			200
		WARN			300
		INFO			400
		DEBUG			500
		TRACE			600
		ALL				Integer.MAX_VALUE
		---------------------------------

	NB : - En fonction de la bibliothèque de Logging les niveaux peuvent varier.
		 - Un fichier JAR est une archive contenant plusieurs fichiers java compilés
	
	Installation la bibliothèque Log4J en v2 (log for J)
		1 - la bibliothèque Log4J doit être téléchargée ici : 
			https://logging.apache.org/log4j/2.x/download.html > la version binary.zip
		2 - ajouter les fichiers jar au projet:
			extraire le fichier zip télécharger
			dans Eclipse clic droit sur le projectname > Build Path > Configure Build Path
			dans le fenetre qui s'ouvre > Librairies > Modulepath > Add External JARs
			allez dans le fichier télécharger (déjà extrait) > apache-log4j-version-bin
			selectionner log4j-api-version.jar et log4j-core-version.jar
			Apply and Close
			Verifier les librairies dans Package Explorer > Projectname > Raferenced Librairies
			
	Utilisation de la bibliothèque Log4J
		1 - Créer le fichier projectname/src/log4j2.properties
			rootLogger = ERROR, STDOUT·							// les logs de la racine sont associé a niveau ERROR
			
			loggers = ej.bloc									// créer un autre log associé au package projetctname.bloc
			logger.ej.bloc.name = ej.bloc						// affecter un nom au logger projetctname.bloc
			logger.ej.bloc.level = INFO							// affecter un nineau au logger projetctname.bloc
			
			appender.console.name = STDOUT						// créer un apppender dans la console
			appender.console.type = Console
			appender.console.layout.type = PatternLayout
			appender.console.layout.pattern = [%-5level] %d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %c{1} - %msg%n		// model de l'affichage

		2 - ajouter des traces
			créer un variable privée dans la classe de type org.apache.logging.log4j.Logger :
				private static Logger logger = LogManager.getLogger(Bloc.class);
			utiliser dans la classe même
				logger.info("ma trace…");						// selon le niveau accepter dans la fichier "log4j2.properties"
		
DEVOIR : voir la documentation (https://logging.apache.org/log4j/2.x/manual/appenders.html) de log4j2 
		car si je crée "projectname/src/log4j2.properties" ça marche pas mais si je ne le crée pas, 
		le log s'affiche normalement dans la console
		
	Voici quelques bonnes pratiques :
		Chaque classe doit avoir sa propre instance de Logger.
		Les traces doivent être datées.
		Les niveaux de logs doivent être définis en fonction des packages.
		Les traces ne doivent pas polluer l’utilisateur final. 
		La configuration du logging doit être externalisée dans un fichier pour pouvoir la modifier à 
			chaud sans avoir à redémarrer l’application.
		Aucune information sensible (comme un mot de passe) ne doit être dans les traces.
	
	

-------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------

Paradigme et paradigme de programmation ?
	-Un paradigme est une façon de voir le monde et ses problèmes.
	-Un paradigme en programmation est une manière d'écrire et visualiser le code. Il s'agit d'un style 
	 de programmation qui définit la façon dont le programme est structuré et exécuté.
	ex : la programmation orientée objet, la programmation impérative, la programmation déclarative,
		 programmation fonctionnelle
	- Un langage est spécialisé dans un paradigme mais il peut utiliser d'autre avec plus ou moins de 
	 difficulté et un résultat plus ou moins efficace.
	 
	Programmation impérative : 
		Description du "comment" : La programmation impérative se concentre sur la description précise 
									des étapes à suivre pour atteindre un résultat. Le développeur spécifie 
									comment le programme doit s'exécuter, en donnant des instructions détaillées.
		Modification de l'état : Les programmes impératifs modifient l'état du programme en manipulant 
									des variables et en exécutant des instructions séquentielles.
		Exemples : C, Java, Python (dans une certaine mesure).

	Programmation déclarative
		Description du "quoi" : La programmation déclarative se concentre sur la description du résultat 
								souhaité, sans préciser comment l'atteindre. Le développeur déclare ce qu'il 
								veut obtenir, laissant le langage ou l'environnement d'exécution déterminer 
								les étapes à suivre.
		Abstraction des détails d'implémentation : Les programmes déclaratifs sont plus abstraits et se 
								concentrent sur la logique de haut niveau plutôt que sur les détails d'implémentation.
		Exemples : SQL, HTML, CSS, Prolog.

NB : Général
    * La JVM fait partie du Java Runtime Environment (JRE). Pour exécuter un programme Java, 
        il suffit d'installer le JRE approprié à votre plateforme. Les développeurs utilisent 
        souvent le Java Development Kit (JDK), qui inclut le JRE ainsi que les outils nécessaires 
        pour écrire et compiler le code Java.
    * C'est le système d'exploitation (avec le JVM : Java Virtual Machine) qui gère 
        automatiquement notre mémoire. On ne peut pas choisir manuellement où à quel adresse 
        mémoire on veut stoker un variable
    * La JVM est une couche d'abstraction qui permet à Java d'être portable, performant et sécurisé. 
        Sans elle, Java ne serait pas aussi universel et polyvalent. C'est elle qui traduit le bytecode (.class)
        indépendant en instructions spécifiques à votre machine, tout en gérant des aspects complexes 
        comme la mémoire et la sécurité.
	* Java est un langage compilé, langage typé, langage objet.
        
	* En Java, le nom d’une classe doit toujours commencer par une majuscule. Le nom du fichier Java 
		doit correspondre au nom de la classe.
	
    * Tout les type primitive java non initialisé ont des valeurs par défaut (int = 0, char = "", ...)
    * Tout les objets java  non initialisé (Array, String, objet d'une classe,...) ont des valeurs par défaut = null
    * on ne fait pas d'import  si :
    	- on utilise des classe dans le même paquage
    	- on utilise des classe dans le paquage java.lang
        
    * Tout les objets java (Array, String, objet d'une classe,...) hérite du classe "Object"
        et peuvent utiliser ses méthodes comme : equals, toString 

    * Monothread : utilise 1 seul thread ou fil d’exécution           // StringBuilder 
    * Multithread : utilise plusieurs thread ou fil d’exécution       // StringBuffer

    * Les concepts de monothreading/multithreading et synchrone/asynchrone sont liés mais DIFFERENT.
    Le monothreading/multithreading concerne l'exécution de plusieurs tâches et le nombre de threads. 
    Le synchrone/asynchrone concerne l'exécution d' une seule tâche et l'attente ou non de son résultat. 
    Comprendre cette différence est crucial pour concevoir des applications performantes et réactives.
    * NB : souvent on utilise le monothreading pour une question de performance. 

	* les 05 signatures d'une foction sont :
		- visibilité : Cet élément influence les zones de code qui seront en droit d’exécuter la fonction.
		- caractéristique : Le comportement d’une fonction peut être altéré par cet élément. Plusieurs mots-clés 
							Java sont applicables ici comme final ou static.
		- type retour : Comme le langage Java est typé il faut définir à l’avance quel type de donnée sera renvoyé.
		- nom : Le nom sera utilisé pour exécuter la fonction au moment voulu.
		- paramètres : Une fonction peut recevoir des données en entrée. Ces données seront alors exploitées 
						durant le traitement.
						
	* Java ne permet pas de mettre de valeur par défaut aux paramètres des méthodes. 
		Le mécanisme de surcharge permet de résoudre ce point comme le montre l’exemple précédent.
	
	* Les techniques de programmation (variable, fonction, condition, itération) appartiennent au paradigme de la
		programmation structurée . Ce paradigme est une base pour de nombreux langages de programmation qui est 
		différent du langage objet.
		
    * si on veut déplacer un fichier ou modifier des choses (comme le nom du package, les import,...) dans java, 
        il faut supprimer le bytecode(.class) et le recompiler 

    * les erreurs dans le console s'appelle les "Piles d'erreurs" (ce sont des informations d'erreurs qui s'empilent) 

    * il faut toujours mettre dans le bloc try-catch les methodes qui peuvent déclencher une exception

    * L'époque Java : un point de référence universel
        C'est définie comme le 1er janvier 1970 à 00h00 UTC (Temps Universel Coordonné). C'est un point de référence 
        temporel standard à partir duquel sont calculées toutes les autres dates et heures en Java.

    * (important) Les classes dans un package ne peuvent pas directement accéder aux classes du package par défaut (classe n'a pas de package).
    
    * Vérifier qu'un comportement qui était fonctionnel l’est toujours après une modification s’appelle un test de non-régression.
    * Une trace ou un log en anglais est une information issue de l’exécution du code de l’application. 




QUELQUE METHODE UTILES ---------------------------------------------------------------------------

        Random random = new Random();
        int randomNumber1 = random.nextInt();		// Génère un nombre entier pseudo-aléatoire
        int randomNumber2 = random.nextInt(10);		// Génère un nombre entier pseudo-aléatoire compris entre 0 (inclus) et 10 (exclus)
        // c'est les même dans nextBoolean(), nextDouble(), nextLong(), nextFloat()
        
		byte[] byteArray = new byte[10];
		random.nextBytes(byteArray);				// Génère un tableau de bytes aléatoires
        


CONTEXT MENU DES EXTENSIONS JAVA VSCODE ---------------------------------------------------------------------------


    ----------------------------------------------------------------------------------------------------
    Option	                        Quand l'utiliser ?
    ----------------------------------------------------------------------------------------------------
    Evaluate in Debug Console	    Pendant le débogage pour tester des expressions.
    Add Inline Breakpoint	        Pour arrêter l'exécution à une ligne spécifique.
    Add to Watch	                Pour suivre une variable pendant l'exécution.
    Run to Cursor	                Pour exécuter jusqu'à une ligne où il y a le curseur.
    Run Java	                    Pour exécuter un fichier Java rapidement.
    Run Project                     Without Debugging	Pour exécuter tout le projet sans interruption.
    Debug Java	                    Pour déboguer un seul fichier.
    Debug Project	                Pour analyser tout le projet en mode débogage.
    ----------------------------------------------------------------------------------------------------


1. Evaluate in Debug Console
    Description :
        - Cette option est disponible lorsque vous êtes en mode débogage.
        - Elle vous permet d'évaluer une expression ou une ligne de code directement dans la console de débogage.
    Utilité :
        - Par exemple, si vous voulez vérifier la valeur d'une variable ou exécuter une méthode pendant l'exécution du programme.


2. Add Inline Breakpoint (Raccourci : Shift+F9)
    Description :
        - Ajoute un point d'arrêt directement sur la ligne de code où vous cliquez.
        - Cela permet au débogueur de s'arrêter à cet endroit lors de l'exécution.
    Utilité :
        - Utile pour examiner les valeurs des variables ou comprendre le flux du programme à des étapes spécifiques.
        - Les points d'arrêt sont essentiels pour déboguer un programme.


3. Add to Watch
    Description :
        - Ajoute une variable ou une expression à la liste de surveillance dans le panneau de débogage.
        - La liste de surveillance vous permet de suivre les changements de valeur de cette variable pendant l'exécution du programme.
    Utilité :
        - Pratique pour surveiller des variables importantes et voir leur évolution sans avoir à les rechercher dans le code.


4. Run to Cursor
    Description :
        - Lance le programme en mode débogage et s'arrête à la ligne où le curseur est positionné.
    Utilité :
        - Permet d'exécuter le programme rapidement jusqu'à une section spécifique sans avoir à ajouter un point d'arrêt.


5. Run Java
    Description :
        - Exécute uniquement le fichier Java sélectionné, sans aucun débogage.
    Utilité :
        - Simplement pour tester un fichier ou exécuter un programme rapidement sans vérifier les erreurs ou comportements détaillés.


6. Run Project Without Debugging
    Description :
        - Exécute l'intégralité du projet Java sans activer le mode débogage.
    Utilité :
        - Utile pour voir si le projet fonctionne correctement de bout en bout sans interruptions dues aux points d'arrêt.


7. Debug Java
    Description :
        - Lance le fichier Java sélectionné en mode débogage.
        - Le programme s'arrête automatiquement à tous les points d'arrêt configurés.
    Utilité :
        - Idéal pour identifier les bugs ou analyser le comportement de sections spécifiques du fichier.


8. Debug Project
    Description :
        - Débogue l'ensemble du projet Java (et non seulement le fichier actuel).
        - Cela inclut tous les fichiers nécessaires à l'exécution, ainsi que les dépendances externes.
    Utilité :
        - Recommandé si votre projet Java comporte plusieurs fichiers ou classes interconnectés, et que vous souhaitez déboguer le comportement global.




---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
-------------------------  CONTEXTE DEVOPS : OUTILS ET LEURS RÔLES  -------------------------------------
---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------

    Git : Gestion du versioning du code source (suivi des modifications, collaboration).
    Maven / Gradle : Automatisation des builds (compilation, tests, packaging).
    Docker : Création de conteneurs d'applications (encapsulation et portabilité).
    Kubernetes : Orchestration des conteneurs (déploiement, mise à l'échelle, gestion).
    Jenkins : Automatisation des pipelines CI/CD (intégration et déploiement continus).
    JUnit : Tests unitaires (vérification du bon fonctionnement du code).
    Cycle de vie d'un build Maven : Commandes et actions

    mvn compile : Compile le code source Java (.java → .class). Sortie : target/classes.
    mvn test : Exécute les tests unitaires. Sortie : target/surefire-reports.
    mvn package : Crée un package distribuable :
    .JAR : pour les applications Java standard.
    .WAR : pour les applications web. Sortie : target.
    mvn install : Installe le package dans le dépôt local Maven (~/.m2/repository).
    mvn deploy : Déploie le package dans un dépôt distant (ex: serveur d'entreprise, Maven Central).
    mvn site : Génère la documentation du projet.

Tableau récapitulatif :
----------------------------------------------------------------------------------------------------
Commande Maven	    Action	                                Répertoire de sortie (principal)        |
----------------------------------------------------------------------------------------------------|
    mvn compile	    Compilation du code source Java	        target/classes                          |
    mvn test	    Exécution des tests unitaires	        target/surefire-reports                 |
    mvn package	    Création du package (JAR ou WAR)	    target                                  |
    mvn install	    Installation du package dans            ~/.m2/repository                        |
                    le dépôt local	                                                                |
    mvn deploy	    Déploiement du package dans un          Dépôt distant                           |
                    dépôt distant	                                                                |
    mvn site	    Génération de la documentation          target/site                             |
                    du projet	                                                                    |
----------------------------------------------------------------------------------------------------

