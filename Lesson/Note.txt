INTRODUCTION ------------------------------------------------------------------------------------------------------

class MainApp {
    public static void main(String[] args) {
        System.out.println("Bonjour tout le monde ! :)");
    }
}


---------------------------------------------------------------------------------------
Type        Type "Objet"    Place en        Fourchette de 
Primitif	Associ√©	        M√©moire	        Valeurs (Min & Max)
---------------------------------------------------------------------------------------
boolean	    Boolean	        1 octet	        true (1), false (0)
byte	    Byte	        1 octet	        -128 √† 127
char	    Character	    2 octets	    Unicode (65536 caract√®res disponibles)
short	    Short	        2 octets	    -32768 √† 32767
int	        Integer	        4 octets	    -2 147 483 648 √† 2 147 483 647
long	    Long	        8 octets	    -2<sup>63</sup> √† +2<sup>63</sup>-1
float	    Float	        4 octets	    1.4x10<sup>-45</sup> √† 3.4x10<sup>38</sup>
double	    Double	        8 octets	    4.9x10<sup>-324</sup> √† 1.7x10<sup>308</sup>
---------------------------------------------------------------------------------------

Notation d'un nombre :
    * 14 
    * 18056
    * 1_128_8531_876 (avec un s√©parateur de millier pour la lisibilit√©)


Base num√©rique : (on peut le fais dans n'importe quel type m√™me String)
    * d√©cimale (10 => 0 √† 9) : 0b110101110  (pr√©fix√© par 0b____ ou \b) 
    * binaire (2 => 0 et 1) : 110_101_110
    * octale (8 => 0 √† 7) : 0755            (pr√©fix√© par 0____ ou \)
    * hexad√©cimale (16 => 0 √† F) :0xAF45    (pr√©fix√© par 0x____ ou \x)


caract√®res sp√©ciaux : 
    \n : nouvelle ligne
    \t : tabulation
    \r : retour chariot
    \b : retour arri√®re
    \f : nouvelle page


FLUX DE CONTROLE ------------------------------------------------------------------------------------------------------

Les conditions on peut l'√©crire sans les accolades sur une seule ligne
    if (value == 24 || value == 16) 
        System.out.println("Oui !"); 
    else if(value == 14)
        System.out.println("value ne vaut 14");
    else
        System.out.println("value ne vaut ni 24 ni 16 ni 14");
        

CLASSE ------------------------------------------------------------------------------------------------------

NB : 
    * On ne peut pas cr√©er un projet java sans une Classe
    * 1 classe = 1 fichier
    * Les propri√©t√©s d'une classe est "public" par d√©faut si 
        on ne me pas de port√©
    * On peut d√©clarer des m√©thodes de m√™me nom si ils n'on pas les 
        m√™me signatures (arguments, type d'arguments, type de retour)
        √áa s'appelle le "Surcharge de m√©thode"

    * le "constructor" porte le nom du classe   
        public class Person {
            public Person() {                           // Constructor
                System.out.println("Person created");
            }
        }

    * on met la methode "static" pour les classes qu'on ne veut pas instancier
        par exemple dans la m√©thode "main"

    * Les valeur par d√©fauts des arguments ne fonctionne pas en java
        public static String sayHello(String name, int NbSister = 1) {          // NO
            return "Hello " + name + " ! You have " + NbSister +" sisters";
        }
        (Sinon on peut simuler avec le surcharge de methodes en cr√©ant plusieurs 
        methode de m√™me nom)


Accesseurs : (encapsulation de donn√©es)
    # getters : r√©cup√©ration d'un propri√©t√© "private" d'une classe (lecture) et d'y ajouter une logique.
        public String getName() {
            return name != null ? name.toUpperCase() : "Nom non d√©fini";
        }

    # setters : modification d'un propri√©t√© "private" d'une classe (√©criture) et d'y ajouter une logique.
        public void setName(String name) {
            if (name != null && !name.isEmpty()) {
                this.name = name;
            } else {
                throw new IllegalArgumentException("Nom invalide");
            }
        }



Variable de Classe :
    private static int maxSoftware = 2;
    public Software(String licence) {
        if (maxSoftware > 0) {
            this.licence = licence;
            maxSoftware--;
        } else {
            System.out.println("Limite atteinte pour creer des logiciels");               
        }
    }


VARIABLE ------------------------------------------------------------------------------------------------------

D√©claration de variable : 
    int tab[] = new int[3];     // reserver en m√©moire 3 adresse de suite (length = 3)
    int[] tab1, tab2            // tous les variables sont des tableaux
    int tab1[], tab2            // seul tab1 est un tableau

    int[] tab = { 81, 25, 37 };             // OK
    int[] tab = new int[3]{81,25,37};       // OK

    System.out.println(tab);                // affiche l'adresse m√©moire du tab               
    System.out.println(tab[0]);             // affiche le valeur du 1er element du tab      

    * le Foreach ou le parcours d'un tableau 
        for (int element : tabX) {             
            System.out.println(element);
        }       

    * Le tableau √† deux dimensions
        int[][] tab = new int[2][3];        => tableau √† 2 lignes et 3 colonnes
        int[][] tab = {{ 81, 25, 37 }, { 81, 25, 37 }};  

    parcours tableau √† deux dimensions:
        for(int i = 0; i < tab.length; i++) {
            for(int j = 0; j < tab[i].length; j++) {
                System.out.println(tab[i][j]);
            }
        }

STRING ------------------------------------------------------------------------------------------------------

STRING : immuable (Contenue non-modifiable) => le syst√®me d√©truit l'ancien adresse et
            cr√©e un nouveau String sur un nouveau adresse (m√™me les methodes toUpperCase(), trim(),...)
    * instanciation de type de l'objet String
        String chaine1= "Hello"
        String chaine2= new String("world")

    * methode utiles : 
        - concat()
        - length() => la longueur du String
        - toUpperCase(), toLowerCase()            
        - trim() => enl√®ve les espaces au d√©but et √† la fin
        - replace("a","o")  => remplace les "a" en "o"
        - charAt(0) => r√©cup√®re le caract√®re au 1er position
        - substring(1, 3) => r√©cup√©rer 3 caract√®re √† partir du l'indice 1 (2√® caract√®re)
        - equals(chaine) => on ne peu pas comparer comme ceci (chaine1 == chaiine2) deux chaines 
        - replaceAll("/", " ") => remplacer tous les "/" en espace " "
        - maString.split ("-") => construire un tableau de String en le s√©parant la chaine "maString" quand il voit "-" 
        
        Exemples :
            String str3 = "See/you/soon";
            System.out.println(str3.replaceAll("/", " "));
            String[] tokens = str3.split("/");
            for (String token : tokens) {
                System.out.println(token);
            }

    * concatenation
        String ch = chaine1 + " " + chaine2                 // plus lourd en m√©moire
        String ch = chaine1.concat(" ").concat(chaine2)     // plus l√©ger, plus rapide

    * le StringBuilder / StringBuffer => immuable (Contenue modifiable) pas comme l'Objet string
        et ils ont le m√™me fonctionnement et meme utilisation
        StringBuilder maString = new StringBuilder();

        - length(), capacity()
        - append(<str>) => c'est comme la m√©thode "push" avec les array
        - insert(<index>, <string>) => ins√©rer une cha√Æne dans un position sp√©cifique


PACKAGE ------------------------------------------------------------------------------------------------------
        
Cr√©ation d'un package:
    - Cr√©er un fichier nompackage/NomFichier.java (nom de package : miniscule, nom de fichier : pascal case)
    - ins√©rer au debut de ligne le nom de package (comme le namespace) et on cr√©e un classe classique
    - s'il y a plusieurs dossier imbriquer, on le s√©pare par un point
        ex : com/weapons/Knife.java
            package com.weapons;
            public class Knife {
                public Knife() {
                    System.out.println("Knife instanci√© !");
                }
            }
    - Remarque : souvient toujours de mettre bien la port√©e de classe, des methodes et des propri√©t√©s (public,...)

Import du package :
    - Dans un autre Classe qui l'utilise, on l'import depuis son nom de package (nompackage.NomClass)
        Remarque : ici on import bien avec son nom de classe mais pas son nom de fichier.
    - si le package est dans le m√™me dossier (parfois), on n'a pas besoin de l'importer  
    - si on veut inclure tous les classes d'une package, on utilise le symbole √©toile "*" (import nompackage.*;)
        ex : src/main.java
            import com.weapons.Knife;          // import la classe
            public class Main {
                public static void main(String[] args) {
                    Knife weapon1 = new Knife();
                }
            }

    
LECTURE AU CLAVIER ------------------------------------------------------------------------------------------------------

    - BufferedReader : lecture de donn√©es en string (multithread)       // plus rapide
    - Scanner : lecture + parsing (int,float,...) (monothread)          // plus lent m√™me si monothread    

    * BufferedReader(<classReader>) : il a besoin de classe de lecture parc'il ne sait pas par d√©faut o√π est
            ce qu'il va lire (les p√©riph√©rique d'entr√©e, un flux, un filchier,...) 
        import java.io.BufferedReader;
        import java.io.InputStreamReader;                               // un flux d'entr√©e

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));    
        System.out.print("Quel est votre nom ? ");
        String name = br.readLine();
    
        - readLine() => lire tous les chaines de caract√®re (sans √† la ligne "\n")  

        NB : il faut rendre la classe en "throws Exception" pour g√©rer les erreur en cas o√π 
            il ne peut pas lire les entr√©es SINON la classe ne se compile pas
            ex : public static void main(String[] args) throws Exception 

    * Scanner(<FluxLecture>) : il n'a besoin de classe de lecture mais juste un flux de lecture (System.in, System.out)
        import java.util.Scanner;

        Scanner sc = new Scanner(System.in);
        
        System.out.print("Quel est votre age ? ");
        int age = sc.nextInt();
        System.out.println("Vous avez " + age + " ans ");
        sc.close();
    
        - nextLine() => lire tous les chaines entr√©e (sans √† la ligne "\n")  
        - nextInt() => lire tous les chaines entr√©e + parseInt
        - nextChar() => lire tous les chaines entr√©e + parseChar
        - nextByte() => lire tous les chaines entr√©e + parseByte
        - nextInFloat() => lire tous les chaines entr√©e + parseFloat
        - nextBoolean() => lire tous les chaines entr√©e + parseBoolean

        NB : 
            * pas besoin "throws Exception"  


EXCEPTION ------------------------------------------------------------------------------------------------------

    Try {
        System.out.print("Quel est votre age ? ");                      // 1 seul block "try"
        int age = sc.nextInt();
        System.out.println("Vous avez " + age + " ans ");
    }
    catch (NomException1 e) {                                           // s'execute si NomException1 se produit
        System.out.println("age n'est pas un nombre");
    }
    catch (NomException2 e) {                                           // s'execute si NomException2 se produit
        System.out.println("age trop grand");
    }
    catch (Exception e) {                                               // s'execute si un exception en g√©n√©ral se produit
        System.out.println("il y a une exception!");
    }
    finaly {
        System.out.println("cet text s'affiche s'il y a une exception ou pas");
    }



HERITAGE ------------------------------------------------------------------------------------------------------

NB : 
    - toute les classes h√©rite de la classe "Object"
    - la port√© "protected" rend une propri√©t√© parent accessible uniquement par ces enfants et petit-enfants
    - "extends" rend une classe enfant d'une autre classe 
    - la methode super() veut dire utiliser le constructor de la classe parent
    - la super.move() veut dire utiliser le methode "move()" de la classe parent
    - les enfants peut utiliser les methodes de la classe sup√©rieur
    - en java, une classe ne peut pas h√©rit√© de plusieurs parents (h√©ritage multiple )
    - mot cl√© "final" :
        * final nomClass = ce classe n'est pas extendable 
        * final nomMethode = ce methode n'est pas redefiniss able dans les classe enfants  
        * final nomVariable = ce classe n'est pas modifiable (constant)

    ex : Horse.java
        package jc.entities;
        public class Horse {
            protected String name;
            protected int posX;
            protected int posY;
            public Horse(String name) {
                this.name = name;
                this.posX = 50;
                this.posY = 50;
            }
            public void move(int x, int y) {
                this.posX = x;
                this.posY = y;
                System.out.println("Le Cheval se d√©place (X = " + this.posX + ", Y = " + this.posY + ")");
            }
        }

    ex : Pegasus.java        
        package jc.entities;
        public class Pegasus extends Horse {
            protected int posZ;
            public Horse(String name) {
                super();
                this.posY = 50;
            }
            public void move(int x, int y) {
                this.posX = x;
                this.posY = y;
                System.out.println("La P√©gase s'envole dans les airs (X = " + this.posX + ", Y = " + this.posY + ", Z = " + this.posZ +")");
            }
        }


CLASSE ABSTRAITE -------------------------------------------------------------------------------------------

    -  Une classe abstraite est une classe qui ne peut pas √™tre instanci√©e directement. 
    -  Elle sert de mod√®le pour d'autres classes.
    
    Caract√©ristiques principales :
        * Peut contenir des m√©thodes abstraites (sans impl√©mentation => qu'on ne d√©finit pas dans la classe)        => au moins une
            et des m√©thodes concr√®tes (avec impl√©mentation => qu'on d√©finie dans la classe).
        * Peut avoir des variables d'instance (propri√©t√©), des constructeurs, et des m√©thodes avec un corps.
        * Une sous-classe doit h√©riter de la classe abstraite et impl√©menter toutes ses m√©thodes abstraites, 
            sauf si la sous-classe elle-m√™me est d√©clar√©e abstraite.
        * peut √©tendre d'une autre classe abstraite

CLASSE ABSTRAITE -------------------------------------------------------------------------------------------

    - Une m√©thode abstraite est une m√©thode qui n‚Äôa pas de corps (pas de code dans les accolades). 
    - Elle est uniquement d√©finie pour √™tre impl√©ment√©e par des sous-classes.

Caract√©ristiques principales :
        * Elle est d√©clar√©e avec le mot-cl√© abstract.
        * Elle ne peut exister que dans une classe abstraite.
        * Elle force les classes d√©riv√©es √† fournir une impl√©mentation.


INTERFACE ---------------------------------------------------------------------------------------------------

    - Une interface en Java est un "contrat". Ce "contrat" stipule que toute classe qui impl√©mente une 
        interface doit fournir des impl√©mentations pour toutes les m√©thodes d√©clar√©es dans cette interface.
    - en terme d'explication, c'est comme si une interface c'est une classe abstraite dont toute les methodes
        sont toutes abstraites.

    - NB :
        * on n'a pas besoin de sp√©cifi√© "public" et "abstract" car toutes est publique et abstrait par d√©faut,
            mais on peut aussi le faire.
        * on fait "interface" au lieu de "class"
        * peut √©tendre d'une autre interface (extends)
        * on emploie le mot cl√© "implements" si une classe veut impl√©menter une interface (Rq : les extends d'abord)
        * une classe peut impl√©menter plusieurs interface (impl√©mentation multiple)
    
    ex : Volant.java
    interface Volant {
        void voler();
    }

    ex : Oiseau.java
    public class Oiseau implements Volant {
        @Override
        public void voler() {
            System.out.println("L'oiseau vole.");
        }
    }

    ex : Avion.java
    public class Avion implements Volant {
        @Override
        public void voler() {
            System.out.println("L'avion vole.");
        }
    }


POLYMORPHISME ---------------------------------------------------------------------------------------------


COLLECTION ---------------------------------------------------------------------------------------------

La collection est une interface qui est l'ensemble de tous ce qui est structure de donn√©es (pile, liste, file,...). 
Elles peut stocker une quantit√© variable des ELEMENTS (donn√©es) qui est g√©rer de fa√ßon dynamique au niveau de la m√©moire.

Les classes qui implements l'interface collection auront ces methodes :
    * add(ELEMENT) : ajouter un √©l√©ment
    * addAll(COLLECTION) : ajouter tous les elements d'une autre collection
    * clear() : supprimer tous les elements d'une collection 
    * remove(INDEX) : supprimer un element
    * contains(ELEMENT) : v√©rifier si elle contient un element
    * isEmpty() : v√©rifier si elle est vide
    * size() : v√©rifier le nombre d'element (length)
    * toArray() : transformer en Array classique
    * ... (voir la documentation)
    - Collections.sort(collections) => trie les elements de la collection (import java.util.Collections)


Les classes qui implements l'interface collection :
    * ArrayList, LinkedList, Vector, HashSet, TreeSet, Stack, HashMap, TreeMap


D√©finition du fichier "ressources/tableau-specificite-des-classes-de-collections.png":
    ~ ordonn√©es : indique si les √©l√©ments de la collection conservent l'ordre dans lequel ils ont √©t√© ajout√©s
    ~ doublons : pr√©cise si la collection autorise plusieurs occurrences du m√™me √©l√©ment (doublons)
    ~ acc√®s direct : indique si les √©l√©ments de la collection peuvent √™tre acc√©d√©s rapidement par un index ou une cl√©. 
                    Si Non, n√©cessite une it√©ration pour trouver un √©l√©ment.
    ~ valeurs nulles : indique si la collection peut contenir des valeurs nulles (√©l√©ments ou cl√©s nulles)
    ~ thread safe : Pr√©cise si la collection est s√ªre pour une utilisation concurrente (acc√®s simultan√© par plusieurs 
                    threads sans provoquer d'erreurs ou de comportements inattendus).
                    ‚úÖ : La collection est con√ßue pour √™tre utilis√©e dans des environnements multithreads.
                    ‚ùå : La collection n'est pas thread-safe et n√©cessite une synchronisation explicite si 
                            utilis√©e avec plusieurs threads.
 
LISTE ---------------------------------------------------------------------------------------------


    Les classes qui implements l'interface LIST sont : (LIST √©tend de COLLECTION)

        * ArrayList : (MonoT, acc√®s direct, optimis√© pour la lecture)               // Tableau dynamique
        * LinkedList :  (MonoT, optimis√© pour l'√©criture)                           // liste cha√Æn√© (doublement cha√Æn√©)
        * Vector : (MultiT, acc√®s direct, optimis√© pour la lecture)                 // Obsolete pour java 21
        * Stack (√©tend Vector) : MultiT, LIFO(pile), extends Vector

    Ces 04 classes ont les sp√©cificit√©s de : 
        - permettent de travailler avec des elements ordonn√©es,
        - acceptent les doublons,
        - acceptent les valeurs nulles


    utilisation : 
        * ArrayList<nomClass> nomVariable = new ArrayList<nomClass>(10);        // nomClass => String, Integer, NomClasse,... (pas de type primitive)
                                                                                // 10 => capacity (on peut ne pas sp√©cifi√© paske c'est dynamique)
                                                                                
        * Vector<nomClass> nomVariable = new Vector<nomClass>(10);              // pour la solution multithread

            --------------------------------------------------------------------------------------------------
                Aspect	            Array	                        ArrayList
            --------------------------------------------------------------------------------------------------
                Taille	            Fixe	                        Dynamique
                Type de donn√©es	    Primitifs et Objets	            Uniquement Objets
                M√©thodes	        Pas de m√©thodes int√©gr√©es	    M√©thodes pour ajouter, supprimer, etc.
                Performance	        Plus rapide pour des 	        Plus lent en raison de sa flexibilit√©
                                    op√©rations simples
                Framework 	        Pas directement compatible	    Compatible
                Collections
            --------------------------------------------------------------------------------------------------
            

            - nomVariable.add(cat) => ajouter l'instance cat de Cat dans nomVariable de type ArrayList<Cat>
            - nomVariable.add(25) => ajouter le nombre "25" dans nomVariable de type ArrayList<Integer>
            - nomVariable.get(2) => r√©cup√©rer le 3√® element de collection nomVariable (acc√®s direct)


        * LinkedList<nomClass> nomVariable2 = new LinkedList<nomClass>();               // liste cha√Æn√©e
            
            - nomVariable2.add(cat) => ajouter l'instance cat de Cat dans nomVariable2 de type LinkedList<Cat> √† la fin
            - nomVariable2.addFirst(cat) => ajouter l'instance cat de Cat dans nomVariable2 de type LinkedList<Cat> au debut
            - nomVariable2.remove(cat) => enlever l'instance cat de Cat dans nomVariable2 de type LinkedList<Cat> √† la fin
            - nomVariable2.removeFirst(cat) => enlever l'instance cat de Cat dans nomVariable2 de type LinkedList<Cat> au debut
            - nomVariable2.getFirst()
            ~ ListIterator : on doit it√©rer la linkedList parce que ses elements n'est pas accessible directement 
                ListIterator<nomClass> iter = nomCollection.listIterator();             // import java.util.ListIterator
                while (iter.hasNext()) {
                    iter.next().nomMethodeClasse();                                      // iter.next = element
                }


            Avantages
                Insertion et suppression rapides (surtout au d√©but ou au milieu).
                Ordre conserv√©.
                Peut √™tre utilis√©e comme une pile (Stack), une file ou une file double (Deque).
            Inconv√©nients
                Acc√®s lent par index : Chaque acc√®s n√©cessite de parcourir la liste depuis le d√©but ou la fin.
                Consommation m√©moire √©lev√©e : Chaque n≈ìud utilise plus de m√©moire (en raison des r√©f√©rences au pr√©c√©dent et au suivant).
                Non thread-safe : N√©cessite une synchronisation manuelle si utilis√©e par plusieurs threads.

                --------------------------------------------------------------------------------------------------
                    Aspect	            LinkedList	                    ArrayList
                --------------------------------------------------------------------------------------------------
                    Taille dynamique	Oui	                            Oui
                    Acc√®s par index	    Lent (parcours des n≈ìuds)	    Rapide (tableau sous-jacent)
                    Ajout/Suppression	Rapide pour d√©but/milieu	    Rapide pour la fin
                    Structure interne	Doublement cha√Æn√©e	            Bas√©e sur un tableau
                    M√©moire	            Plus gourmand 	                Moins gourmand
                                        (stocke des r√©f√©rences)
                --------------------------------------------------------------------------------------------------


        * Stack<nomClass> nomVariable3 = new Stack<nomClass>();               // pile (LIFO), import java.util.ListIterator
        
            - nomVariable3.push(cat) => ajouter l'instance cat de Cat dans la collection nomVariable3
            - nomVariable3.pop() => supprimer le dernier instance dans la collection nomVariable3 
            - nomVariable3.peek() => r√©cup√©rer le dernier instance dans la collection nomVariable3

            
FILE (Queue) - FIFO (First in, First out) -----------------------------------------------------------

    L‚Äôinterface "Queue" repr√©sente une file d'attente (FIFO : First In, First Out).c'est une enfant de 
    Collection dans ressources/interface-enfant-de-collection.png: (file d'attente)
    
    Les deux principales sous-interfaces :

        - PriorityQueue
            Une PriorityQueue est une file o√π les √©l√©ments ne sont pas n√©cessairement trait√©s selon leur ordre d'insertion, 
            mais selon leur priorit√© d√©finie par un ordre naturel (Comparable) ou un comparateur (Comparator).

            * Caract√©ristiques :
                ~ ‚úÖ Ordonn√©e : Ordre bas√© sur la priorit√© des √©l√©ments.
                ~ ‚úÖ Doublons
                ~ ‚ùå acc√®s direct.
                ~ ‚ùå non thread-safe.
                ~ ‚ùå valeurs null.

            * PriorityQueue<nomClass> queue = new PriorityQueue<>();        // nomClass n'a pas besoin d'implementer l'interface comparable 
                                                                                parce qu'il est ordonn√©e par l'ordre d'insertion
            * queue.offer(element) => ajout d'√©l√©ment
            * queue.poll(element) => r√©cup√©rer ensuite supprimer le 1er √©l√©ment selon l'ordre de priorit√©

        
        - Deque (Double-Ended Queue = Tableau doublement cha√Æn√©e)
            L‚Äôinterface "Deque" est une file d'attente qui permet d'ajouter et de retirer des √©l√©ments √† 
            la fois au d√©but et √† la fin. Elle est plus flexible que Queue et peut √™tre utilis√©e comme une 
            pile (LIFO) ou une file classique (FIFO).

            * Caract√©ristiques :
                ~ ‚úÖ Ordonn√©e : Ordre d'insertion.
                ~ ‚úÖ Doublons
                ~ ‚ùå acc√®s direct.
                ~ ‚ùå non thread-safe.
                ~ ‚ùå valeurs null.
                ‚úÖ Permet l'ajout/suppression des deux c√¥t√©s.
                ‚úÖ Impl√©ment√©e par LinkedList ou ArrayDeque(plus rapide).
                ‚úÖ ArrayDeque est plus rapide que Stack et ne permet pas null.

            * ArrayDeque :
                ArrayDeque<nomClass> adeque = new ArrayDeque<>();            // nomClass doit implementer l'interface comparable 
                                                                            // les Integer, String,... impl√©mentent d√©j√† comparable
                ~ adeque.addFirst(element) / addLast(element)
                ~ adeque.removeFirst() / removeLast()
                ~ adeque.getFirst() / getLast()
                ~ adeque.offertFirst(element) / offertLast(element)
                ~ adeque.pollFirst() / pollLast()
                ~ adeque.peekFirst() / peekLast()
                ~ adeque.removeFirstOccurrence(4) : supprimer le 1er valeur "4" du collection "adeque"
                ~ adeque.removeLastOccurrence(5) : supprimer le dernier valeur "4" du collection "adeque"



ENSEMBLE (SET) ------------------------------------------------------------------

    L'interface Set<E> (du package java.util) est une collection qui ne permet pas les doublons. 
    Elle est principalement utilis√©e lorsque vous devez stocker des √©l√©ments uniques et que l'ordre 
    des √©l√©ments n'est pas votre priorit√©.
    
    * Caract√©ristiques :
        ‚ùå Doublons.
        ‚ùå non thread-safe.

    1. HashSet ‚Äì Unicit√© sans ordre
        Un HashSet est bas√© sur une table de hachage, garantissant que chaque √©l√©ment est unique 
        gr√¢ce √† la m√©thode hashCode().

        Caract√©ristiques :
            ‚ùå ordonn√©es.
            ‚ùå Non thread-safe
            ‚úÖ acc√®s direct.
            ‚úÖ Autorise un √©l√©ment null, mais pas plusieurs.
            ‚úÖ Tr√®s performant pour les recherches, ajouts et suppressions (O(1) en moyenne).

        Syntaxe : 
            HashSet<String> set = new HashSet<>();

    
    2. LinkedHashSet ‚Äì Unicit√© avec ordre d‚Äôinsertion
        C‚Äôest une variante de HashSet qui pr√©serve l‚Äôordre d‚Äôinsertion des √©l√©ments.

        Caract√©ristiques :
            ‚úÖ ordonn√©e : l‚Äôordre d‚Äôinsertion.
            ‚úÖ Un peu plus lent que HashSet, car il utilise une liste doublement cha√Æn√©e pour suivre l‚Äôordre.
            ‚úÖ Permet un null unique.
            
        Syntaxe : 
            HashSet<String> set = new HashSet<>();


    3. TreeSet ‚Äì Unicit√© avec tri automatique (arbre binaire)
        Un TreeSet est bas√© sur un arbre binaire √©quilibr√© (Red-Black Tree), ce qui permet 
        de stocker les √©l√©ments tri√©s.

        Caract√©ristiques :
            ‚úÖ ordonn√©e : l‚Äôordre naturel (Comparable) ou un Comparator personnalis√©.
            ‚ùå Non thread-safe
            ‚ùå acc√®s direct.
            ‚ùå valeurs null.
            ‚ùå Plus lent que HashSet pour l‚Äôinsertion et la recherche (O(log N) au lieu de O(1)).
            
        Syntaxe : 
            TreeSet<Integer> TSet = new TreeSet<>();

            ~ TSet.first(element) / last(element) : r√©cup√©rer
            ~ TSet.headSet(element) : r√©cup√©rer un sous ensemble de la collection depuis le debut jusqu'√† "element" (element exclus)
            ~ TSet.tailSet(element) : r√©cup√©rer un sous ensemble de la collection depuis "element" jusqu'√† la fin (element inclus)
            ~ TSet.subSet(elem1, elem2) : r√©cup√©rer un sous ensemble de la collection depuis "elem1" jusqu'√† la "elem2" (elem1 inclus, elem2 exclus)



    NB : - tous les Classes d'elements qui vont s'ajouter dans la collection "SET" vont devoir r√©-implementer
            les methodes "hashCode()" et "equals()" pour que les interface "SET" recherche les doublons. (sauf Integer, String,...)
         - les elements de "TreeSet" devoir r√©-implementer les comparators.




CARTE (MAP) (key : value) ------------------------------------------------------------------

    L'interface Map<K, V> (du package java.util) repr√©sente une collection cl√©-valeur, o√π :
        - Chaque cl√© est unique (pas de doublons de cl√©).
        - Chaque valeur est associ√©e √† une cl√©.
        - L'acc√®s aux valeurs se fait via les cl√©s.
    
    * Caract√©ristiques :
        ‚úÖ acc√®s direct.
        ‚ùå Doublons (key).
        ‚ùå non thread-safe.

    1. HashMap ‚Äì Rapide mais sans ordre
        Une HashMap est bas√©e sur une table de hachage et permet un acc√®s tr√®s rapide aux valeurs via 
        leurs cl√©s.

        Caract√©ristiques :
            ‚ùå ordonn√©e
            ‚úÖ une seule cl√© null et plusieurs valeurs null.
            ‚úÖ Excellente performance pour la recherche, l‚Äôajout et la suppression (O(1) en moyenne).

        Syntaxe : 
            HashMap<String, String> HMap = new HashMap<>();

            ~ HMap.put(key, value) : ajouter un element
            ~ HMap.get(key) : r√©cup√©rer un la valeur de l'element qui a la cl√© "key"
            ~ HMap.containsKey(key) / contains(value)
            ~ for( String k : HMap.keySet()) : parcours HMap
                * keySet() => ensemble des cl√©s
                * values() => ensemble des valeurs
            ~ for( Map.Entry<String, String> entry : HMap.entrySet()) => ensemble des cl√©s-valeurs (des entr√©es, des enregistrements)
                * entry.getKey()
                * entry.getValue()


    2. LinkedHashMap ‚Äì Ordre d‚Äôinsertion pr√©serv√©
        Un LinkedHashMap est une version am√©lior√©e de HashMap qui conserve l‚Äôordre d‚Äôinsertion des √©l√©ments.

        Caract√©ristiques :
            ‚úÖ Conserve l‚Äôordre d‚Äôinsertion.
            ‚úÖ Permet une seule cl√© null et plusieurs valeurs null.
            ‚ùå L√©g√®rement plus lent que HashMap, car il maintient une liste cha√Æn√©e pour l‚Äôordre.

        Syntaxe : 
            LinkedHashMap<Integer, String> LHmap = new LinkedHashMap<>();


    3. TreeMap ‚Äì Tri automatique des cl√©s
        Un TreeMap est bas√© sur un arbre binaire √©quilibr√© (Red-Black Tree) et trie automatiquement les cl√©s.

        Caract√©ristiques :
            ‚úÖ Ordonn√©e : ordre naturel (Comparable) ou un Comparator.
            ‚úÖ Ne permet pas de cl√© null, mais permet des valeurs null.
            ‚ùå Plus lent que HashMap pour l‚Äôajout et la suppression (O(log N) au lieu de O(1)).

        Syntaxe : 
            TreeMap<Integer, String> Tmap = new TreeMap<>();

            ~ Tmap.put(element) / last(element) : ajout / r√©cup√©rer
            ~ TreeMap<Integer, String> map = new TreeMap<>((a, b) -> b - a);        // Trier (alphabet d√©croissant)

    -----------------------------------------------------------------------------------------------------------------
    Crit√®re	            HashMap	              LinkedHashMap	            TreeMap	            Hashtable
    -----------------------------------------------------------------------------------------------------------------
    Ordre des           ‚ùå Non garanti	    ‚úÖ Ordre d‚Äôinsertion	    üî¢ Tri√© par cl√©	    ‚ùå Non garanti
    √©l√©ments	
    Performance	        üöÄ O(1)	             üê¢ O(1) (plus lent)	  üêå O(log N)	      üê¢ O(1) (moins efficace)
    (Ajout/Suppression)
    Recherche	        O(1)	              O(1)	                    O(log N)	        O(1)
    Cl√© null autoris√©e	‚úÖ Oui (une seule)	‚úÖ Oui (une seule)	    ‚ùå Non	            ‚ùå Non
    Valeur null 	    ‚úÖ Oui	            ‚úÖ Oui	                ‚úÖ Oui	            ‚ùå Non
    autoris√©e
    Thread-safe ?	    ‚ùå Non	            ‚ùå Non	                ‚ùå Non	            ‚úÖ Oui
    -----------------------------------------------------------------------------------------------------------------
    
    Quand utiliser quel Map ?
        ‚úî Utilisez HashMap si vous voulez les meilleures performances sans vous soucier de l‚Äôordre.
        ‚úî Utilisez LinkedHashMap si vous voulez conserver l‚Äôordre d‚Äôinsertion.
        ‚úî Utilisez TreeMap si vous avez besoin d‚Äôun tri automatique des cl√©s.
        ‚úî √âvitez Hashtable, utilisez plut√¥t ConcurrentHashMap si vous avez besoin d‚Äôune Map



ENUMERATION (ENUM) -------------------------------------------------------------------------

    En Java, une √©num√©ration (ou "enum") est un type de classe sp√©cial qui permet de d√©finir un 
    ensemble fixe de constantes nomm√©es.
        public enum Jour {
            LUNDI, MARDI, MERCREDI, JEUDI, VENDREDI, SAMEDI, DIMANCHE
        }

        Jour jour = Jour.LUNDI;
        System.out.println(jour);       // LUNDI


    * Associer des valeurs avec les "enum"
        public enum Statut {
            ACTIF(1), INACTIF(0), SUSPENDU(-1);

            private int code; // Attribut

            Statut(int code) { // Constructeur
                this.code = code;
            }

            public int getCode() { // Getter
                return code;
            }
        }

        Statut s = Statut.ACTIF;
        System.out.println(s.getCode()); // 1


    * Ajouter des m√©thodes (ex : Trouver un enum √† partir d‚Äôun code)

        public enum Statut {
            ACTIF(1), INACTIF(0), SUSPENDU(-1);

            private int code;

            Statut(int code) {
                this.code = code;
            }

            public int getCode() {
                return code;
            }

            public static Statut fromCode(int code) {
                for (Statut s : Statut.values()) {
                    if (s.getCode() == code) {
                        return s;
                    }
                }
                throw new IllegalArgumentException("Code inconnu : " + code);
            }
        }

        Statut s = Statut.fromCode(1);
        System.out.println(s); // ACTIF


    * Diff√©rence entre enum et final static
        Avant les enum, on utilisait souvent final static pour repr√©senter des constantes :

            public class Statut {
                public static final int ACTIF = 1;
                public static final int INACTIF = 0;
                public static final int SUSPENDU = -1;
            }

        üìå Pourquoi enum est mieux ?
            ‚úî S√©curit√© ‚Üí Impossible de mettre une valeur inconnue (ex: Statut.ACTIF est s√ªr).
            ‚úî Lisibilit√© ‚Üí Pas besoin de se souvenir des valeurs (1, 0, -1 sont abstraits).
            ‚úî Fonctionnalit√©s ‚Üí Peut contenir des m√©thodes et √™tre utilis√© avec switch.
            ‚úî comparaison ‚Üí avec simplemnt "=="

    
    ~ Statut.valueOf(element) : recuperer la valeur d'√©l√©ments de l'enum "Statut"
    ~ element.name() : recuperer le nom d'√©l√©ments d'une enum
    ~ element.ordinal() : recuperer le rang de l'enum (comme index)
    ~ for (Statut s : Statut.values()) : parcours (values => obtenir tous les √©l√©ments d'une enum)
    

NB : 
    - on ne peut pas √©tendre d'une Classe ni √©tendre une Enum (parce que c'est une classe final)
    - on ne peut pas cr√©er un instance d'un Enum (parce que le constructeur est priv√©)




GENERICITE <T> --------------------------------------------------------------------------

    La g√©n√©ricit√© en Java est une fonctionnalit√© qui permet de cr√©er des classes, des interfaces et des 
    m√©thodes qui peuvent √™tre utilis√©es avec diff√©rents types de donn√©es sans avoir √† les sp√©cifier 
    explicitement √† chaque fois :

            public class Boite<T> {
                private T contenu;

                public Boite(T contenu) {
                    this.contenu = contenu;
                }

                public T getContenu() {
                    return contenu;
                }

                public void setContenu(T contenu) {
                    this.contenu = contenu;
                }
            }

            Boite<Integer> boiteEntier = new Boite<>(10);
            Boite<String> boiteChaine = new Boite<>("Bonjour");


        ~ public class Boite<T extends Number> : accepte tous les Objet qui √©tend la classe "Number"    (Box<Double> doubleBox = new Box<>(5.5))
        ~ class KeyValue<K, V> implements Pair<K, V> : implement l'interface Pair<K, V>                 ( Pair<Integer, String> p = new KeyValue<>(1, "One"); )
        ~ public static void printNumbers(List<? extends Number> numbers)
                List<Integer> intList = List.of(1, 2, 3);
                printNumbers(intList); // ‚úÖ OK, Integer est un Number
        ~ public static void addInteger(List<? super Integer> list)
                List<Number> numList = new ArrayList<>();
                addInteger(numList); // ‚úÖ OK, Number est une superclasse de Integer

    NB :
        En Java, on ne peut pas cr√©er directement un tableau de type g√©n√©rique.
        Solution : Utiliser Array.newInstance()
            class Box<T> {
                private T[] array;

                @SuppressWarnings("unchecked")
                public Box(Class<T> clazz, int size) {
                    array = (T[]) java.lang.reflect.Array.newInstance(clazz, size);
                }
            }
        
        Box<String> stringBox = new Box<>(String.class, 10);

    -----------------------------------------------------------------------------------------------------
        Crit√®re	            List<?> (Wildcard g√©n√©rique)	    List<T> (Type param√©tr√©)
    -----------------------------------------------------------------------------------------------------
        Flexibilit√©	        Accepte toutes les listes 	        Type unique d√©fini (List<T>, 
                            (List<Integer>, List<String>...)    ex: List<Integer>)
        Lecture (get())	    ‚úÖ Possible	                      ‚úÖ Possible
        Ajout (add())	    üö´ Impossible (sauf null)	       ‚úÖ Possible (ajout d'√©l√©ments du type T)
        Utilisation de T	‚ùå Pas de T, seulement Object	  ‚úÖ Utilisation directe de T
    -----------------------------------------------------------------------------------------------------
     Quand utiliser quoi ?
        ------------------------------------------------------------------------------------
            Cas d'usage	                                     Quelle version choisir ?
        ------------------------------------------------------------------------------------
            Lecture seule, sans modifier la liste	        List<?> (car plus flexible)
            Lecture + Ajout d‚Äô√©l√©ments du m√™me type	        List<T> (car permet les ajouts)
            M√©thode acceptant plusieurs types (Integer,	    List<?>
            String, etc.)
        ------------------------------------------------------------------------------------
    üìå Exemple pratique :
        List<?> : Id√©al pour une m√©thode d'affichage qui ne doit pas modifier la liste.
        List<T> : Id√©al pour une m√©thode qui manipule les √©l√©ments (ajout, suppression, transformation...).



    - Avantages de la g√©n√©ricit√© :
        S√©curit√© du type: La g√©n√©ricit√© permet de s'assurer que les donn√©es manipul√©es sont du bon type au 
                            moment de la compilation, ce qui √©vite les erreurs de type √† l'ex√©cution.
        R√©utilisabilit√© du code: La g√©n√©ricit√© permet de cr√©er des classes et des m√©thodes qui peuvent √™tre 
                            utilis√©es avec diff√©rents types de donn√©es, ce qui r√©duit la quantit√© de code √† √©crire et √† maintenir.
        Lisibilit√© du code: La g√©n√©ricit√© rend le code plus lisible en indiquant clairement le type de donn√©es
                            manipul√©es.



DATE ET DUR√âES --------------------------------------------------------------------------------

    1Ô∏è‚É£ LocalDate ‚Äì Manipulation de la date uniquement
        Utilis√© quand seule la date est importante (sans heure).

        Ex :
            import java.time.LocalDate;
            public class Main {
                public static void main(String[] args) {
                    // Date actuelle
                    LocalDate today = LocalDate.now();
                    System.out.println("Aujourd'hui : " + today);               // 2025-02-05 (Ann√©e - Mois - Jour)

                    // Date sp√©cifique (ann√©e, mois, jour)
                    LocalDate date = LocalDate.of(2025, 2, 5);      
                    System.out.println("Date sp√©cifique : " + date);            // 2025-02-05

                    // Ajouter/Soustraire des jours/mois/ann√©es
                    LocalDate futureDate = today.plusDays(10);
                    LocalDate pastDate = today.minusMonths(2);
                    System.out.println("Dans 10 jours : " + futureDate);        // 2025-02-15
                    System.out.println("Il y a 2 mois : " + pastDate);          // 2024-12-05

                    // Comparaison de dates
                    boolean isBefore = date.isBefore(today);
                    boolean isAfter = date.isAfter(today);
                    System.out.println("Est avant aujourd'hui ? " + isBefore);  // false
                    System.out.println("Est apr√®s aujourd'hui ? " + isAfter);   // false
                }
            }

            instanciation :
                ~ LocalDate.EPOCH() : cr√©er une date "1970-01-01"
                ~ LocalDate.now() : cr√©er une date d'aujourd'hui
                ~ LocalDate.of(1988, 03, 14) : cr√©er une date sp√©cifique (ann√©e - mois - jour)
            methodes :
                ~ myDate.getYear() : r√©cup√©rer l'ann√©e
                ~ myDate.getMonthValue() : r√©cup√©rer le mois num√©rique (ex: 03)
                ~ myDate.getMonth() : r√©cup√©rer le mois literal (ex: MARCH)
                ~ myDate.getDayOfMonth() : r√©cup√©rer le mois num√©rique (ex: 22)
                ~ myDate.getDayOfWeek() : r√©cup√©rer le mois literal (ex: Saturday)
                ~ myDate.plusYears(4) / plusMonths(15) / plusDays(35) : ajout d'ann√©e/mois/jours
                ~ myDate.minusYears(4) / minusMonths(15) / minusDays(35) : soustraction d'ann√©e/mois/jours
                ~ myDate.plus(Period)



    2Ô∏è‚É£ LocalTime ‚Äì Manipulation de l'heure uniquement
        Utilis√© quand seule l‚Äôheure est importante (sans date).

        Ex :
            import java.time.LocalTime;
            public class Main {
                public static void main(String[] args) {
                    // Heure actuelle
                    LocalTime now = LocalTime.now();
                    System.out.println("Heure actuelle : " + now);              // 14:45:10.123

                    // Heure sp√©cifique (heures, minutes, secondes)
                    LocalTime time = LocalTime.of(14, 30, 15);
                    System.out.println("Heure sp√©cifique : " + time);           // 14:30:15

                    // Ajouter/Soustraire des heures/minutes/secondes
                    LocalTime futureTime = now.plusHours(3);
                    LocalTime pastTime = now.minusMinutes(20);
                    System.out.println("Dans 3 heures : " + futureTime);        // 17:45:10.123
                    System.out.println("Il y a 20 minutes : " + pastTime);      // 14:25:10.123

                    // Comparaison d'heures
                    boolean isBefore = time.isBefore(now);
                    boolean isAfter = time.isAfter(now);
                    System.out.println("Est avant maintenant ? " + isBefore);   // true
                    System.out.println("Est apr√®s maintenant ? " + isAfter);    // false
                }
            }

            instanciation :
                ~ LocalTime.now() : cr√©er un temps d'aujourd'hui
                ~ LocalTime.of(19, 03, 14) : cr√©er un temps sp√©cifique (heure - minute - sec)
            methodes :
                ~ myTime.getHour() : r√©cup√©rer l'heure
                ~ myTime.getMinute() : r√©cup√©rer le minute
                ~ myTime.plusHours(4) / plusMinutes(15) / plusSecondes(35) : ajout 
                ~ myTime.minusHours(4) / minusMinutes(15) / minusSecondes(35) : soustraction 
                ~ myTime.plus(Duration) : ajout d'une dur√©e 


    3Ô∏è‚É£ LocalDateTime ‚Äì Combinaison de date et heure
        Utilis√© quand date + heure sont importantes ensemble.

        Ex :
            import java.time.LocalDateTime;
            public class Main {
                public static void main(String[] args) {
                    // Date et heure actuelles
                    LocalDateTime now = LocalDateTime.now();
                    System.out.println("Date et heure actuelles : " + now);                 // 2025-02-05T14:45:10.123

                    // Date et heure sp√©cifiques
                    LocalDateTime dateTime = LocalDateTime.of(2025, 2, 5, 14, 30, 15);
                    System.out.println("Date et heure sp√©cifiques : " + dateTime);          // 2025-02-05T14:30:15

                    // Ajouter/Soustraire du temps
                    LocalDateTime futureDateTime = now.plusDays(5).plusHours(2);
                    LocalDateTime pastDateTime = now.minusMonths(1).minusMinutes(30);
                    System.out.println("Dans 5 jours et 2 heures : " + futureDateTime);     // 2025-02-10T16:45:10.123
                    System.out.println("Il y a 1 mois et 30 minutes : " + pastDateTime);    // 2025-01-05T14:15:10.123
                }
            }

            instanciation :
                ~ LocalDateTime.now() 
                ~ LocalDateTime.of(someDate, someTime) : cr√©er un temps sp√©cifique (Annee - Mois - Jour - heure - minute - sec)
            methodes : tout les methodes de LocalDate et LocalTime

    5Ô∏è‚É£ Dur√©es et P√©riodes (Duration et Period)
        Period ‚Üí Dur√©e (jours, mois, ann√©es)

            Ex :
                import java.time.LocalDate;
                import java.time.Period;
                public class Main {
                    public static void main(String[] args) {
                        LocalDate startDate = LocalDate.of(2024, 1, 1);
                        LocalDate endDate = LocalDate.of(2025, 2, 5);

                        Period period = Period.between(startDate, endDate);

                        System.out.println("Diff√©rence : " + period.getYears() + " ans, " + 
                            period.getMonths() + " mois, " + period.getDays() + " jours");
                    }
                }

            methodes :
                ~ Period.of(03, 04, 06) : cr√©er un Dur√©e de 3ans, 4mois et 6j
                ~ Period.between(startDate, endDate) : cr√©er une dur√©e entre startDate et endDate


        Duration ‚Üí Dur√©e (heures, minutes, secondes)

            Ex :
                import java.time.Duration;
                import java.time.LocalTime;
                public class Main {
                    public static void main(String[] args) {
                        LocalTime startTime = LocalTime.of(10, 30);
                        LocalTime endTime = LocalTime.of(14, 45);

                        Duration duration = Duration.between(startTime, endTime);

                        System.out.println("Dur√©e : " + duration.toHours() + " heures, " + 
                            duration.toMinutes() % 60 + " minutes");
                    }
                }

            methodes :
                ~ Duration.ofHours(3).plusMinutes(30) : cr√©er une dur√©e de 03h30    // affiche PT03H30
                ~ Duration.between(startTime, endTime) : cr√©er une dur√©e entre startTime et endTime


    6Ô∏è‚É£ Timezones avec ZoneId et ZonedDateTime

        üìå ZoneId ‚Äì Repr√©sente un fuseau horaire
            ZoneId permet de d√©finir un fuseau horaire sp√©cifique (ex : "Europe/Paris", "GMT+3").

                import java.time.ZoneId;
                public class Main {
                    public static void main(String[] args) {
                        // Afficher le fuseau horaire par d√©faut
                        ZoneId defaultZone = ZoneId.systemDefault();
                        System.out.println("Fuseau par d√©faut : " + defaultZone);

                        // D√©finir un fuseau horaire sp√©cifique
                        ZoneId parisZone = ZoneId.of("Europe/Paris");
                        System.out.println("Fuseau horaire de Paris : " + parisZone);
                    }
                }

        üìå ZonedDateTime ‚Äì Manipuler une date/heure avec un fuseau horaire
            ZonedDateTime associe une date, une heure et un fuseau horaire.

                import java.time.ZonedDateTime;
                import java.time.ZoneId;
                public class Main {
                    public static void main(String[] args) {
                        // Date et heure actuelles avec fuseau par d√©faut
                        ZonedDateTime now = ZonedDateTime.now();
                        System.out.println("Date et heure actuelles : " + now);                 // 2025-02-06T14:45:10.123+01:00[Europe/Paris]

                        // Date et heure actuelles avec un fuseau horaire sp√©cifique
                        ZonedDateTime parisTime = ZonedDateTime.now(ZoneId.of("Europe/Paris"));
                        System.out.println("Heure de Paris : " + parisTime);                    // 2025-02-06T14:45:10.123+01:00[Europe/Paris]

                        // Convertir une LocalDateTime en ZonedDateTime
                        ZonedDateTime newYorkTime = parisTime.withZoneSameInstant(ZoneId.of("America/New_York"));
                        System.out.println("Heure de New York : " + newYorkTime);               // 2025-02-06T08:45:10.123-05:00[America/New_York]
                    }
                }


    7Ô∏è‚É£ Formatage des Dates (DateTimeFormatter)
                import java.time.LocalDateTime;
                import java.time.format.DateTimeFormatter;
                public class Main {
                    public static void main(String[] args) {
                        LocalDateTime now = LocalDateTime.now();

                        // D√©finir un format personnalis√©
                        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("dd/MM/yyyy HH:mm:ss");

                        // Formater la date
                        String formattedDate = now.format(formatter);
                        System.out.println("Date format√©e : " + formattedDate);
                    }
                }

            -------------------------------------------------------
                Motif	Exemple	    Description
            -------------------------------------------------------
                yyyy	2025	    Ann√©e sur 4 chiffres
                yy	    25	        Ann√©e sur 2 chiffres
                MM	    02	        Mois sur 2 chiffres
                MMM	    F√©v	        Mois abr√©g√©
                MMMM	F√©vrier	    Mois en toutes lettres
                dd	    06	        Jour sur 2 chiffres
                HH	    14	        Heure (24h)
                hh	    02	        Heure (12h)
                mm	    45	        Minutes
                ss	    10	        Secondes
            -------------------------------------------------------



THREADS ---------------------------------------------------------------------------------------------------

    Java prend en charge le multithreading, permettant d'ex√©cuter plusieurs t√¢ches en parall√®le pour 
    am√©liorer les performances des applications.

    Un thread est un sous-processus l√©ger qui peut s'ex√©cuter ind√©pendamment. Par d√©faut, un programme 
    Java s'ex√©cute sur un thread principal appel√© main thread.
        import java.lang.Thread; 
        System.out.println("Thread principal : " + Thread.currentThread().getName());           // main

    Il existe trois fa√ßons principales de cr√©er un thread :

        1Ô∏è‚É£ En √©tendant Thread : On cr√©e une classe qui h√©rite de Thread et on red√©finit la m√©thode run().
            (Ne pas appeler run() directement, sinon il s‚Äôex√©cutera comme une m√©thode normale)

            class MonThread extends Thread {
                public void run() {
                    System.out.println("Ex√©cution du thread : " + Thread.currentThread().getName());
                }
            }

            MonThread thread1 = new MonThread();
            thread1.start();  // D√©marrer le thread > Thread-0
            

        2Ô∏è‚É£ En impl√©mentant Runnable (Best Practice ‚úÖ)
            class MonRunnable implements Runnable {
                public void run() {
                    System.out.println("Thread en cours d'ex√©cution : " + Thread.currentThread().getName());
                }
            }

            Thread thread2 = new Thread(new MonRunnable());
            thread2.start();

            ~ Thread.sleep(1000) => faire un pause de 1000ms
            ~ Thread.sleep() => 


        3Ô∏è‚É£ Les "Executors" pour √™tre plus moderne      // java.util.concurrent
            - newSingleThreadExecutor(): la possibilit√© d'avoir un thread
            - newCachedThreadPool(): la possibilit√© d'avoir un thread dynamique
            - newFixedThreadPool(): la possibilit√© d'avoir un nombre fixe de thread (pour les traitement plus lent)


            ~ ExecutorService ex = Executors.newSingleThreadExecutor();
            ~ ExecutorService ex = Executors.newCachedThreadPool();
            ~ ExecutorService ex = Executors.newFixedThreadPool(4);             // 4 = nbr de threads 

                Runnable task = () -> {                 // expression lambda
                    ...
                }

                ex.execute(task);                       // executer task dans le "newSingleThreadExecutor"
                ex.shutdown();                          // Ferme l'executor apr√®s ex√©cution

            avec ExecutorService on peut:
                * fermer l'executor apr√®s ex√©cution avec shutdown()
                * avoir les resultats d'execution avec les "Future" (java.util.concurrent)
                    Future<?> fut = executor.submit(task)       // <?> : g√©n√©rique (on ne sait pas quel type il r√©cup√®re)
                    ~ fut.isDone() => est fini (boolean)
                    ~ fut.isCanceled() => est annul√© (boolean)
                    ~ fut.get() => recup√©re les resultats
                    ~ fut.cancel() => annuler


DASE DE DONNEES ---------------------------------------------------------------------------------------------------

    JDBC est l'API standard de Java pour interagir avec une base de donn√©es relationnelle (comme MySQL, 
    PostgreSQL, Oracle, etc.). Elle permet aux applications Java d‚Äôex√©cuter des requ√™tes SQL et de manipuler 
    les donn√©es.

    Pour interagir avec une base de donn√©es via JDBC, il faut suivre ces 5 √©tapes :
        - Charger le Driver JDBC : mettre un pilote dans le classpath pour permettre √† Java de communiquer 
                                    avec une base de donn√©es
        - √âtablir une Connexion : On utilise DriverManager pour √©tablir une connexion avec la base de donn√©es
        - Ex√©cuter des Requ√™tes SQL : On utilise Statement pour ex√©cuter des requ√™tes SQL.
        - Utiliser PreparedStatement : pour plus de S√©curis√© ‚úÖ
        - Fermer la Connexion 



-------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------


NB : G√©n√©ral
    * La JVM fait partie du Java Runtime Environment (JRE). Pour ex√©cuter un programme Java, 
        il suffit d'installer le JRE appropri√© √† votre plateforme. Les d√©veloppeurs utilisent 
        souvent le Java Development Kit (JDK), qui inclut le JRE ainsi que les outils n√©cessaires 
        pour √©crire et compiler le code Java.
    * C'est le syst√®me d'exploitation (avec le JVM : Java Virtual Machine) qui g√®re 
        automatiquement notre m√©moire. On ne peut pas choisir manuellement o√π √† quel adresse 
        m√©moire on veut stoker un variable
    * La JVM est une couche d'abstraction qui permet √† Java d'√™tre portable, performant et s√©curis√©. 
        Sans elle, Java ne serait pas aussi universel et polyvalent. C'est elle qui traduit le bytecode (.class)
        ind√©pendant en instructions sp√©cifiques √† votre machine, tout en g√©rant des aspects complexes 
        comme la m√©moire et la s√©curit√©.

    * Tou les objets java (Array, String, objet d'une classe,...) h√©rite du classe "Object"
        et peuvent utiliser ses m√©thodes comme : equals, toString 

    * Monothread : utilise 1 seul thread ou fil d‚Äôex√©cution           // StringBuilder 
    * Multithread : utilise plusieurs thread ou fil d‚Äôex√©cution       // StringBuffer

    * Les concepts de monothreading/multithreading et synchrone/asynchrone sont li√©s mais DIFFERENT.
    Le monothreading/multithreading concerne l'ex√©cution de plusieurs t√¢ches et le nombre de threads. 
    Le synchrone/asynchrone concerne l'ex√©cution d' une seule t√¢che et l'attente ou non de son r√©sultat. 
    Comprendre cette diff√©rence est crucial pour concevoir des applications performantes et r√©actives.
    * NB : souvent on utilise le monothreading pour une question de performance. 

    * si on veut d√©placer un fichier ou modifier des choses (comme le nom du package, les import,...) dans java, 
        il faut supprimer le bytecode(.class) et le recompiler 

    * les erreurs dans le console s'appelle les "Piles d'erreurs" (ce sont des informations d'erreurs qui s'empilent) 

    * il faut toujours mettre dans le bloc try-catch les methodes qui peuvent d√©clencher une exception

    * L'√©poque Java : un point de r√©f√©rence universel
        C'est d√©finie comme le 1er janvier 1970 √† 00h00 UTC (Temps Universel Coordonn√©). C'est un point de r√©f√©rence 
        temporel standard √† partir duquel sont calcul√©es toutes les autres dates et heures en Java.

    * (important) Les classes dans un package ne peuvent pas directement acc√©der aux classes du package par d√©faut (classe n'a pas de package).



CONTEXT MENU DES EXTENSIONS JAVA VSCODE ---------------------------------------------------------------------------


    ----------------------------------------------------------------------------------------------------
    Option	                        Quand l'utiliser ?
    ----------------------------------------------------------------------------------------------------
    Evaluate in Debug Console	    Pendant le d√©bogage pour tester des expressions.
    Add Inline Breakpoint	        Pour arr√™ter l'ex√©cution √† une ligne sp√©cifique.
    Add to Watch	                Pour suivre une variable pendant l'ex√©cution.
    Run to Cursor	                Pour ex√©cuter jusqu'√† une ligne o√π il y a le curseur.
    Run Java	                    Pour ex√©cuter un fichier Java rapidement.
    Run Project                     Without Debugging	Pour ex√©cuter tout le projet sans interruption.
    Debug Java	                    Pour d√©boguer un seul fichier.
    Debug Project	                Pour analyser tout le projet en mode d√©bogage.
    ----------------------------------------------------------------------------------------------------


1. Evaluate in Debug Console
    Description :
        - Cette option est disponible lorsque vous √™tes en mode d√©bogage.
        - Elle vous permet d'√©valuer une expression ou une ligne de code directement dans la console de d√©bogage.
    Utilit√© :
        - Par exemple, si vous voulez v√©rifier la valeur d'une variable ou ex√©cuter une m√©thode pendant l'ex√©cution du programme.


2. Add Inline Breakpoint (Raccourci : Shift+F9)
    Description :
        - Ajoute un point d'arr√™t directement sur la ligne de code o√π vous cliquez.
        - Cela permet au d√©bogueur de s'arr√™ter √† cet endroit lors de l'ex√©cution.
    Utilit√© :
        - Utile pour examiner les valeurs des variables ou comprendre le flux du programme √† des √©tapes sp√©cifiques.
        - Les points d'arr√™t sont essentiels pour d√©boguer un programme.


3. Add to Watch
    Description :
        - Ajoute une variable ou une expression √† la liste de surveillance dans le panneau de d√©bogage.
        - La liste de surveillance vous permet de suivre les changements de valeur de cette variable pendant l'ex√©cution du programme.
    Utilit√© :
        - Pratique pour surveiller des variables importantes et voir leur √©volution sans avoir √† les rechercher dans le code.


4. Run to Cursor
    Description :
        - Lance le programme en mode d√©bogage et s'arr√™te √† la ligne o√π le curseur est positionn√©.
    Utilit√© :
        - Permet d'ex√©cuter le programme rapidement jusqu'√† une section sp√©cifique sans avoir √† ajouter un point d'arr√™t.


5. Run Java
    Description :
        - Ex√©cute uniquement le fichier Java s√©lectionn√©, sans aucun d√©bogage.
    Utilit√© :
        - Simplement pour tester un fichier ou ex√©cuter un programme rapidement sans v√©rifier les erreurs ou comportements d√©taill√©s.


6. Run Project Without Debugging
    Description :
        - Ex√©cute l'int√©gralit√© du projet Java sans activer le mode d√©bogage.
    Utilit√© :
        - Utile pour voir si le projet fonctionne correctement de bout en bout sans interruptions dues aux points d'arr√™t.


7. Debug Java
    Description :
        - Lance le fichier Java s√©lectionn√© en mode d√©bogage.
        - Le programme s'arr√™te automatiquement √† tous les points d'arr√™t configur√©s.
    Utilit√© :
        - Id√©al pour identifier les bugs ou analyser le comportement de sections sp√©cifiques du fichier.


8. Debug Project
    Description :
        - D√©bogue l'ensemble du projet Java (et non seulement le fichier actuel).
        - Cela inclut tous les fichiers n√©cessaires √† l'ex√©cution, ainsi que les d√©pendances externes.
    Utilit√© :
        - Recommand√© si votre projet Java comporte plusieurs fichiers ou classes interconnect√©s, et que vous souhaitez d√©boguer le comportement global.




---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
-------------------------  CONTEXTE DEVOPS : OUTILS ET LEURS R√îLES  -------------------------------------
---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------

    Git : Gestion du versioning du code source (suivi des modifications, collaboration).
    Maven / Gradle : Automatisation des builds (compilation, tests, packaging).
    Docker : Cr√©ation de conteneurs d'applications (encapsulation et portabilit√©).
    Kubernetes : Orchestration des conteneurs (d√©ploiement, mise √† l'√©chelle, gestion).
    Jenkins : Automatisation des pipelines CI/CD (int√©gration et d√©ploiement continus).
    JUnit : Tests unitaires (v√©rification du bon fonctionnement du code).
    Cycle de vie d'un build Maven : Commandes et actions

    mvn compile : Compile le code source Java (.java ‚Üí .class). Sortie : target/classes.
    mvn test : Ex√©cute les tests unitaires. Sortie : target/surefire-reports.
    mvn package : Cr√©e un package distribuable :
    .JAR : pour les applications Java standard.
    .WAR : pour les applications web. Sortie : target.
    mvn install : Installe le package dans le d√©p√¥t local Maven (~/.m2/repository).
    mvn deploy : D√©ploie le package dans un d√©p√¥t distant (ex: serveur d'entreprise, Maven Central).
    mvn site : G√©n√®re la documentation du projet.

Tableau r√©capitulatif :
----------------------------------------------------------------------------------------------------
Commande Maven	    Action	                                R√©pertoire de sortie (principal)        |
----------------------------------------------------------------------------------------------------|
    mvn compile	    Compilation du code source Java	        target/classes                          |
    mvn test	    Ex√©cution des tests unitaires	        target/surefire-reports                 |
    mvn package	    Cr√©ation du package (JAR ou WAR)	    target                                  |
    mvn install	    Installation du package dans            ~/.m2/repository                        |
                    le d√©p√¥t local	                                                                |
    mvn deploy	    D√©ploiement du package dans un          D√©p√¥t distant                           |
                    d√©p√¥t distant	                                                                |
    mvn site	    G√©n√©ration de la documentation          target/site                             |
                    du projet	                                                                    |
----------------------------------------------------------------------------------------------------

