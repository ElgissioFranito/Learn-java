---------------------------------------------------------------------------------------------------------
Toujours mettre une classe dans un package, parce que :
    - Puisque une classe n'a pas de dÃ©claration de package, Java considÃ¨re qu'il est dans le package par dÃ©faut.
    - (important) Les classes dans un package ne peuvent pas directement accÃ©der aux classes du package par dÃ©faut.


---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------

COLLECTIONS :

En pratique, voici les collections les plus utilisÃ©es en entreprise et dans les projets Java rÃ©els.

1ï¸âƒ£ La collection List la plus utilisÃ©e : ArrayList
    ğŸ“Œ Pourquoi ?
        Stocke les Ã©lÃ©ments dans un tableau dynamique â†’ AccÃ¨s rapide (O(1)).
        UtilisÃ©e pour des listes oÃ¹ lâ€™ordre des Ã©lÃ©ments est important.
        TrÃ¨s performante en lecture et accÃ¨s indexÃ©.

    ğŸ“Œ Exemple concret :
        Stocker une liste dâ€™utilisateurs dans une application.
        GÃ©rer un panier dâ€™achats dans un site e-commerce.
            List<String> users = new ArrayList<>();
            users.add("Alice");
            users.add("Bob");
            System.out.println(users.get(0)); // Alice

    ğŸ‘‰ Quand Ã©viter ArrayList ?
        Si vous avez beaucoup dâ€™ajouts/suppressions en milieu de liste, utilisez plutÃ´t LinkedList (mais câ€™est rare en vrai).

2ï¸âƒ£ La collection Queue la plus utilisÃ©e : PriorityQueue
    ğŸ“Œ Pourquoi ?
        Permet de gÃ©rer une file dâ€™attente avec des prioritÃ©s.
        TrÃ¨s utilisÃ©e dans les algorithmes et la gestion de tÃ¢ches asynchrones.

    ğŸ“Œ Exemple concret :
        SystÃ¨me de tickets (support client) : les clients VIP sont servis en premier.
        Planification de tÃ¢ches (scheduler dâ€™un OS).
            PriorityQueue<Integer> queue = new PriorityQueue<>();
            queue.add(3);
            queue.add(1);
            queue.add(2);
            System.out.println(queue.poll()); // 1 (plus petite prioritÃ© en premier)

ğŸ‘‰ Quand Ã©viter PriorityQueue ?
Si vous voulez une file classique FIFO, utilisez simplement ArrayDeque.

3ï¸âƒ£ La collection Set la plus utilisÃ©e : HashSet
    ğŸ“Œ Pourquoi ?
        Ã‰vite les doublons et offre une recherche ultra rapide (O(1)).
        UtilisÃ©e pour gÃ©rer des ensembles uniques de donnÃ©es.

    ğŸ“Œ Exemple concret :
        Liste dâ€™adresses e-mail uniques.
        VÃ©rifier si un utilisateur a dÃ©jÃ  votÃ© dans un sondage.
            Set<String> emails = new HashSet<>();
            emails.add("alice@gmail.com");
            emails.add("bob@gmail.com");
            emails.add("alice@gmail.com"); // IgnorÃ© car dÃ©jÃ  prÃ©sent

    ğŸ‘‰ Quand Ã©viter HashSet ?
        Si lâ€™ordre dâ€™insertion est important, utilisez LinkedHashSet.
        Si vous avez besoin dâ€™un tri automatique, utilisez TreeSet.

4ï¸âƒ£ La collection Map la plus utilisÃ©e : HashMap
    ğŸ“Œ Pourquoi ?
        Permet dâ€™associer une clÃ© unique Ã  une valeur.
        Rapide (O(1)) et trÃ¨s utilisÃ© partout en dÃ©veloppement 

    ğŸ“Œ Exemple concret :
        Dictionnaire (clÃ© = mot, valeur = dÃ©finition).
        Stocker les paramÃ¨tres dâ€™une configuration.
        Mapper un ID utilisateur Ã  ses informations.
            Map<Integer, String> users = new HashMap<>();
            users.put(1, "Alice");
            users.put(2, "Bob");
            System.out.println(users.get(1)); // Alice
    ğŸ‘‰ Quand Ã©viter HashMap ?
        Si vous avez besoin dâ€™un tri automatique des clÃ©s, utilisez TreeMap.
        Si lâ€™ordre dâ€™insertion est important, utilisez LinkedHashMap.

ğŸ“Œ En rÃ©sumÃ© : Les collections les plus utilisÃ©es en entreprise
------------------------------------------------------------------------------------------------
CatÃ©gorie	Collection la 	    Pourquoi ?
            plus utilisÃ©e
------------------------------------------------------------------------------------------------
List	    ArrayList	        Rapide, ordre conservÃ©, accÃ¨s direct (O(1))
Queue	    PriorityQueue	    Gestion des prioritÃ©s (ex : files dâ€™attente, planification)
Set	        HashSet	            Ã‰vite les doublons, recherche ultra rapide (O(1))
Map	        HashMap	            Stocke des paires clÃ©-valeur, ultra performant (O(1))
------------------------------------------------------------------------------------------------

ğŸš€ Conclusion :
    Si tu dois retenir une seule collection par catÃ©gorie, retiens :
        âœ” ArrayList pour les listes ğŸ“‹
        âœ” PriorityQueue pour les files prioritaires ğŸ“¥
        âœ” HashSet pour les ensembles uniques ğŸ”—
        âœ” HashMap pour les paires clÃ©-valeur ğŸ—ºï¸

Câ€™est 90% des cas dâ€™usage en entreprise ! ğŸ’¡


--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------

MAVEN ET TOMCAT :

En Java, Maven et Tomcat sont deux outils distincts qui servent des objectifs diffÃ©rents :

1. Maven
Maven est un outil de gestion de projet et de build utilisÃ© principalement pour automatiser la compilation, la gestion des dÃ©pendances et le packaging des applications Java. Il repose sur un fichier de configuration XML appelÃ© pom.xml (Project Object Model).

ğŸ”¹ Principales fonctionnalitÃ©s de Maven :
âœ… Gestion automatique des dÃ©pendances (via le dÃ©pÃ´t central de Maven)
âœ… Compilation et packaging du code
âœ… ExÃ©cution des tests unitaires
âœ… GÃ©nÃ©ration de documentation
âœ… Standardisation des projets Java

ğŸ‘‰ Exemple d'un pom.xml pour un projet Spring Boot :

xml
Copier
<project xmlns="http://maven.apache.org/POM/4.0.0"  
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0  
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.example</groupId>
    <artifactId>demo</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
            <version>3.2.1</version>
        </dependency>
    </dependencies>
</project>
Avec Maven, il suffit dâ€™exÃ©cuter :

bash
Copier
mvn clean install
pour compiler et gÃ©nÃ©rer lâ€™application.

2. Tomcat
Tomcat est un serveur dâ€™applications Java EE (Jakarta EE) qui sert Ã  exÃ©cuter des applications web Java basÃ©es sur Servlets et JSP (JavaServer Pages).

ğŸ”¹ Principales fonctionnalitÃ©s de Tomcat :
âœ… HÃ©bergement et exÃ©cution dâ€™applications Java web
âœ… Gestion des requÃªtes HTTP via des Servlets
âœ… Support des JSP et des WebSockets
âœ… Configuration et dÃ©ploiement via un fichier server.xml

ğŸ‘‰ Exemple dâ€™utilisation :
Si on a une application web Java sous forme de fichier war (webapp.war), on peut la dÃ©ployer dans Tomcat en la plaÃ§ant dans le dossier :

bash
Copier
apache-tomcat/webapps/
Ensuite, on dÃ©marre Tomcat avec :

bash
Copier
./bin/startup.sh   # Sur Linux/Mac
bin\startup.bat    # Sur Windows
Lâ€™application sera accessible via :

bash
Copier
http://localhost:8080/webapp
DiffÃ©rences entre Maven et Tomcat
Outil	RÃ´le
Maven	GÃ¨re les dÃ©pendances, la compilation et le packaging d'un projet Java
Tomcat	Sert dâ€™environnement dâ€™exÃ©cution pour les applications web Java
En gros, Maven sert Ã  construire ton application, et Tomcat sert Ã  lâ€™exÃ©cuter si câ€™est une application web.

Si tu veux faire du Spring Boot, sache que Spring Boot intÃ¨gre un serveur Tomcat embarquÃ©, donc tu peux lancer ton app directement avec mvn spring-boot:run.

--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------

ğŸ“‚ GESTION DES FICHIERS EN JAVA

Java propose plusieurs classes pour manipuler des fichiers, principalement dans le package 
java.nio.file (modern API) et java.io (ancienne API).

1ï¸âƒ£ Lire et Ã‰crire dans un Fichier en Java

    ğŸ“Œ Lire un fichier (Files.readAllLines)
        La mÃ©thode Files.readAllLines() permet de lire un fichier texte en une seule fois.

            import java.nio.file.Files;
            import java.nio.file.Path;
            import java.nio.file.Paths;
            import java.io.IOException;
            import java.util.List;

            public class Main {
                public static void main(String[] args) {
                    Path filePath = Paths.get("example.txt");

                    try {
                        List<String> lines = Files.readAllLines(filePath);
                        for (String line : lines) {
                            System.out.println(line);
                        }
                    } catch (IOException e) {
                        System.out.println("Erreur de lecture : " + e.getMessage());
                    }
                }
            }

        âœ… Avantages : Lecture simple en une seule ligne.
        âš  InconvÃ©nient : Pas adaptÃ© aux gros fichiers (charge toute la mÃ©moire).

    ğŸ“Œ Lire un fichier ligne par ligne (Files.lines())
        Files.lines() est plus efficace car il utilise un Stream.

            import java.nio.file.Files;
            import java.nio.file.Path;
            import java.nio.file.Paths;
            import java.io.IOException;

            public class Main {
                public static void main(String[] args) {
                    Path filePath = Paths.get("example.txt");

                    try {
                        Files.lines(filePath).forEach(System.out::println);
                    } catch (IOException e) {
                        System.out.println("Erreur de lecture : " + e.getMessage());
                    }
                }
            }

        âœ… Avantages : OptimisÃ© pour les gros fichiers (lecture ligne par ligne).
        âš  InconvÃ©nient : NÃ©cessite de fermer le Stream manuellement si on l'affecte Ã  une variable.

    ğŸ“Œ Ã‰crire dans un fichier (Files.write())
        Files.write() permet d'Ã©crire rapidement dans un fichier.

            import java.nio.file.Files;
            import java.nio.file.Path;
            import java.nio.file.Paths;
            import java.io.IOException;
            import java.util.Arrays;

            public class Main {
                public static void main(String[] args) {
                    Path filePath = Paths.get("example.txt");
                    try {
                        Files.write(filePath, Arrays.asList("Ligne 1", "Ligne 2", "Ligne 3"));
                        System.out.println("Fichier Ã©crit avec succÃ¨s !");
                    } catch (IOException e) {
                        System.out.println("Erreur d'Ã©criture : " + e.getMessage());
                    }
                }
            }

        âœ… Avantages : Simple et rapide.
        âš  InconvÃ©nient : Ã‰crase le fichier existant (âš  pas d'ajout de texte).

    ğŸ“Œ Ajouter du texte sans Ã©craser (Files.write() avec StandardOpenOption.APPEND)

            import java.nio.file.Files;
            import java.nio.file.Path;
            import java.nio.file.Paths;
            import java.io.IOException;
            import java.nio.file.StandardOpenOption;
            import java.util.Collections;

            public class Main {
                public static void main(String[] args) {
                    Path filePath = Paths.get("example.txt");
                    try {
                        Files.write(filePath, Collections.singletonList("Nouvelle ligne"), StandardOpenOption.APPEND);
                        System.out.println("Texte ajoutÃ© avec succÃ¨s !");
                    } catch (IOException e) {
                        System.out.println("Erreur d'Ã©criture : " + e.getMessage());
                    }
                }
            }

        âœ… Avantages : Permet dâ€™ajouter du texte sans Ã©craser.

2ï¸âƒ£ Manipulation des Fichiers et Dossiers

    ğŸ“Œ VÃ©rifier si un fichier/dossier existe (Files.exists())

            import java.nio.file.Files;
            import java.nio.file.Path;
            import java.nio.file.Paths;

            public class Main {
                public static void main(String[] args) {
                    Path filePath = Paths.get("example.txt");

                    if (Files.exists(filePath)) {
                        System.out.println("Le fichier existe !");
                    } else {
                        System.out.println("Le fichier n'existe pas.");
                    }
                }
            }

        âœ… Avantages : Simple et efficace.

ğŸ“Œ Supprimer un fichier (Files.delete())

        import java.nio.file.Files;
        import java.nio.file.Path;
        import java.nio.file.Paths;
        import java.io.IOException;

        public class Main {
            public static void main(String[] args) {
                Path filePath = Paths.get("example.txt");

                try {
                    Files.delete(filePath);
                    System.out.println("Fichier supprimÃ© !");
                } catch (IOException e) {
                    System.out.println("Erreur de suppression : " + e.getMessage());
                }
            }
        }

    âš  Attention : Si le fichier nâ€™existe pas, une exception est levÃ©e.

ğŸ“Œ CrÃ©er un dossier (Files.createDirectory())

        import java.nio.file.Files;
        import java.nio.file.Path;
        import java.nio.file.Paths;
        import java.io.IOException;

        public class Main {
            public static void main(String[] args) {
                Path dirPath = Paths.get("monDossier");

                try {
                    Files.createDirectory(dirPath);
                    System.out.println("Dossier crÃ©Ã© !");
                } catch (IOException e) {
                    System.out.println("Erreur de crÃ©ation du dossier : " + e.getMessage());
                }
            }
        }

    âš  Si le dossier existe dÃ©jÃ , une erreur est levÃ©e.

3ï¸âƒ£ Lecture et Ã‰criture avec BufferedReader et BufferedWriter
    ğŸ“Œ Lire un fichier avec BufferedReader (RecommandÃ© pour les gros fichiers)

            import java.io.BufferedReader;
            import java.io.FileReader;
            import java.io.IOException;

            public class Main {
                public static void main(String[] args) {
                    try (BufferedReader reader = new BufferedReader(new FileReader("example.txt"))) {
                        String line;
                        while ((line = reader.readLine()) != null) {
                            System.out.println(line);
                        }
                    } catch (IOException e) {
                        System.out.println("Erreur de lecture : " + e.getMessage());
                    }
                }
            }

        âœ… Avantages : Utilise un buffer pour optimiser la lecture.

    ğŸ“Œ Ã‰crire dans un fichier avec BufferedWriter

            import java.io.BufferedWriter;
            import java.io.FileWriter;
            import java.io.IOException;

            public class Main {
                public static void main(String[] args) {
                    try (BufferedWriter writer = new BufferedWriter(new FileWriter("example.txt"))) {
                        writer.write("Hello, World!");
                        writer.newLine();  // Ajoute une nouvelle ligne
                        writer.write("DeuxiÃ¨me ligne");
                        System.out.println("Ã‰criture rÃ©ussie !");
                    } catch (IOException e) {
                        System.out.println("Erreur d'Ã©criture : " + e.getMessage());
                    }
                }
            }

        âœ… Avantages : OptimisÃ© pour lâ€™Ã©criture avec un buffer.

    ğŸ“Œ Comparaison des MÃ©thodes

        ---------------------------------------------------------------------------------------------
            MÃ©thode	                Lecture	              Ã‰criture	            OptimisÃ© pour gros fichiers ?
        ---------------------------------------------------------------------------------------------
            Files.readAllLines()	âœ… Facile	        âŒ Pas d'Ã©criture	    âŒ Non
            Files.lines()	        âœ… Efficace	        âŒ Pas d'Ã©criture	    âœ… Oui
            BufferedReader	        âœ… TrÃ¨s efficace	    âŒ Pas d'Ã©criture	    âœ… Oui
            BufferedWriter	        âŒ Pas de lecture	âœ… Efficace	            âœ… Oui
            Files.write()	        âŒ Pas de lecture	âœ… Simple	            âŒ Non
        ---------------------------------------------------------------------------------------------

        âœ… Conclusion
        ğŸ”¹ Pour de petits fichiers, utilisez Files.readAllLines() et Files.write().
        ğŸ”¹ Pour de gros fichiers, utilisez BufferedReader et BufferedWriter.
        ğŸ”¹ Pour ajouter du texte sans Ã©craser, utilisez Files.write() avec StandardOpenOption.APPEND.
        ğŸ”¹ Pour manipuler les fichiers/dossiers, utilisez Files.exists(), Files.createDirectory(), Files.delete().
        